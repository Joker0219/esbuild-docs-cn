title: API
body:
  - h1: API
  - p: >
      API 可以以三种方式使用：在命令行中、在 JavaScript 中以及在 Go 中。
      在这三种语言中，概念与参数几乎是一模一样的，因此他们可以一起出现在这里，
      而不是针对每一种语言淡出出一份文档。

  - p: >
      在 esbuild 中有两个比较主要的 API：[transform](#transform-api)
      与 [build](#build-api)。理解你应该使用哪一个是非常重要的，
      因为他们的工作方式不同。

  - p: >
      如果你是用的是 JavaScript，请务必阅读下面的 [JS-specific details](#js-specific-details) 章节。
      你也可以找到 esbuild 的 [TypeScript 类型定义](https://github.com/evanw/esbuild/blob/master/lib/types.ts)
      for esbuild helpful 作为参考。如果正在使用 Go 语言，请务必阅读自动生成的
       [Go 文档](https://pkg.go.dev/github.com/evanw/esbuild/pkg/api)。If you are using Go be sure to check

  - h2: Transform API

  - p: >
      transform API 操作单个字符串，而不访问文件系统。
      这使其能够比较理想地在没有文件系统的环境中使用（比如浏览器）或者作为另一个工具链的一部分。
      以下是一个比较简单的 transform 示例：

  - example:
      cli:
        - $: |
            echo 'let x: number = 1' | esbuild --loader=ts
        - expect: |
            let x = 1;

      js:
        - $: |
            require('esbuild').transformSync('let x: number = 1', {
              loader: 'ts',
            })
        - expect: |
            {
              code: 'let x = 1;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("let x: number = 1", api.TransformOptions{
            Loader: api.LoaderTS,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      如果没有提供输入的文件并且没有 `--bundle` 标志的话，命令行接口就会调用此 API。
      在这个用例中，输入的字符串来自标准输入（stdin），并且输出字符串转到标准输出（stdout）。
      transform API 可以使用以下配置项：

  - available-options:
    - Banner
    - Charset
    - Color
    - Define
    - Footer
    - Format
    - Global name
    - JSX factory
    - JSX fragment
    - Keep names
    - Loader
    - Log level
    - Log limit
    - Minify
    - Pure
    - Source Root
    - Sourcefile
    - Sourcemap
    - Sources Content
    - Target
    - Tree shaking
    - Tsconfig raw

  - h2: Build API

  - p: >
      调用 build API 操作文件系统中的一个或多个文件。
      它允许文件互相引用并且打包在一起。
      这里是一个简单的 build 用例：

  - example:
      cli:
        - $: |
            echo 'let x: number = 1' > in.ts
        - $: |
            esbuild in.ts --outfile=out.js
        - $: |
            cat out.js
        - expect: |
            let x = 1;

      js:
        - $: |
            require('fs').writeFileSync('in.ts', 'let x: number = 1')
        - $: |
            require('esbuild').buildSync({
              entryPoints: ['in.ts'],
              outfile: 'out.js',
            })
        - expect: |
            { warnings: [] }
        - $: |
            require('fs').readFileSync('out.js', 'utf8')
        - expect: |
            'let x = 1;\n'

      go: |
        package main

        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          ioutil.WriteFile("in.ts", []byte("let x: number = 1"), 0644)

          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"in.ts"},
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      如果至少提供一个输入文件或者存在 `--bundle` 标志，那么命令行接口会调用该 API。
      请注意 esbuild _不会_ 默认打包。你必须传递 `--bundle` 标志启用打包。
      如果没有提供输入文件，则从标准化输入（stdin）读取单个输入文件。build API 可以使用以下配置项：

  - available-options:
    - Asset names
    - Banner
    - Bundle
    - Charset
    - Chunk names
    - Color
    - Conditions
    - Define
    - Entry names
    - External
    - Footer
    - Format
    - Global name
    - Incremental
    - Inject
    - JSX factory
    - JSX fragment
    - Keep names
    - Loader
    - Log level
    - Log limit
    - Main fields
    - Metafile
    - Minify
    - Node paths
    - Out extension
    - Outbase
    - Outdir
    - Outfile
    - Platform
    - Preserve symlinks
    - Public path
    - Pure
    - Resolve extensions
    - Serve
    - Source Root
    - Sourcefile
    - Sourcemap
    - Sources Content
    - Splitting
    - Stdin
    - Target
    - Tree shaking
    - Tsconfig
    - Watch
    - Working Directory
    - Write

  - h2: 一般配置项

  - h3: Bundle

  - p: >
      打包一个文件意味着将任何导入的依赖项内联到文件中。
      这个过程是递归的，因为依赖的依赖（等等）也将被内联。
      默认情况下，esbuild 将 _不会_ 打包输入的文件。
      打包必须想这样显式启用：

  - example:
      in:
        in.js: '1 + 2'

      cli: |
          esbuild in.js --bundle

      js:
        - $: |
            require('esbuild').buildSync({
              entryPoints: ['in.js'],
              bundle: true,
              outfile: 'out.js',
            })
        - expect: |
            { warnings: [] }

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"in.js"},
            Bundle:      true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      点击 [快速开始指引](/getting-started/#your-first-bundle)
      查看打包实际代码的例子。

  - p: >
      请注意打包与文件连接不同。在启用打包时向 esbuild 传递多个输入文件将创建两个单独的
      bundle 而不是将输入文件连接在一起。为了使用 esbuild 将一系列文件打包在一起，
      在一个入口起点文件中引入所有文件，然后就像打包一个文件那样将它们打包。

  - h3: Define

  - p: >
      该特性提供了一种用常量表达式替换全局标识符的方法。
      它可以在不改变代码本身的情况下改变某些构建之间代码的行为:

  - example:
      cli:
        - $: |
            echo 'DEBUG && require("hooks")' | esbuild --define:DEBUG=true
        - expect: |
            require("hooks");

        - $: |
            echo 'DEBUG && require("hooks")' | esbuild --define:DEBUG=false
        - expect: |
            false;

      js:
        - $: let js = 'DEBUG && require("hooks")'

        - $: |
            require('esbuild').transformSync(js, {
              define: { DEBUG: 'true' },
            })
        - expect: |
            {
              code: 'require("hooks");\n',
              map: '',
              warnings: []
            }

        - $: |
            require('esbuild').transformSync(js, {
              define: { DEBUG: 'false' },
            })
        - expect: |
            {
              code: 'false;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "DEBUG && require('hooks')"

          result1 := api.Transform(js, api.TransformOptions{
            Define: map[string]string{"DEBUG": "true"},
          })

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(js, api.TransformOptions{
            Define: map[string]string{"DEBUG": "false"},
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }
        }

  - p: >
      替换表达式必须是一个 JSON 对象（null、boolean、number、string、array 或者 object）
      或者一个标识符。除了数组和对象之外，替换表达式是内联替换的，这意味着他们可以参与常数折叠。
      数组与对象替换表达式会被存储在一个变量中，然后被标识符引用而不是内联替换，
      这避免了替换重复复制一个值，但也意味着该值不能参与常数折叠。

  - p: >
      如果你想用字符串字面值替换某些东西，记住，传递给esbuild的替换值本身必须包含引号。
      省略引号意味着替换的值是一个标识符：

  - example:
      cli:
        - $: |
            echo 'id, str' | esbuild --define:id=text --define:str=\"text\"
        - expect: |
            text, "text";

      js:
        - $: |
            require('esbuild').transformSync('id, str', {
              define: { id: 'text', str: '"text"' },
            })
        - expect: |
            {
              code: 'text, "text";\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("id, text", api.TransformOptions{
            Define: map[string]string{
              "id":  "text",
              "str": "\"text\"",
            },
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      如果你在使用 CLI 工具，请记住，不同的 shell 对于如何转义双引号字符有不同的规则
      （当替换的值为一个字符串时会非常必要）。使用 `\"` 反斜杠转义，因为它可以在 bash
      以及 Windows 命令提示符中生效。其他在 bash 中有效的转义双引号的方法，比如用单引号括起来，
      在Windows上不起作用，因为 Windows 命令提示符不会删除单引号。这和你在 `package.json` 的
      npm script 中使用 CLI 工具是相关的，人们期望在所有平台上工作：

  - pre.json: |
      {
        "scripts": {
          "build": "esbuild --define:process.env.NODE_ENV=\\\"production\\\" app.js"
        }
      }

  - p: >
      如果你仍然在不同的 shell 中遇到跨平台引号转义问题，你讲可能会选择使用 [JavaScript API](/api/)。
      There you can use regular JavaScript syntax to eliminate
      你可以使用常规的 JavaScript 语法来消除跨平台差异。

  - h3: External

  - p: >
      你可以标记一个文件或者包为外部（external），从而将其从你的打包结果中移除。
      导入将被保留（对于 `iife` 以及 `cjs` 格式使用 `require`，对于 `esm` 格式使用 `import`），而不是被打包，
      并将在运行时进行计算。

  - p: >
      这里有几个用法。首先，它可以用于去除你的 bundle 中你知道将永远不会被执行的代码路径中的无用代码。
      例如，一个 package 可以会包含值运行在 node 端的代码，但是你只会将其用在浏览器中。
      它还可以用于在运行时从不能打包的包导入 node 中的代码。例如，`fsevents` 包含 esbuild 不支持的本地拓展，
      像这样将某些内容标记为外部（external）：

  - example:
      cli:
        - $: |
            echo 'require("fsevents")' > app.js
        - $: |
            esbuild app.js --bundle --external:fsevents
        - expect: |
            (() => {
              // app.js
              require("fsevents");
            })();

      js:
        - $: |
            require('fs').writeFileSync('app.js', 'require("fsevents")')
        - $: |
            require('esbuild').buildSync({
              entryPoints: ['app.js'],
              outfile: 'out.js',
              bundle: true,
              external: ['fsevents'],
            })
        - expect: |
            { warnings: [] }

      go: |
        package main

        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          ioutil.WriteFile("app.js", []byte("require(\"fsevents\")"), 0644)

          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Outfile:     "out.js",
            Bundle:      true,
            Write:       true,
            External:    []string{"fsevents"},
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      你也可以在外部（external）路径中使用 `*` 通配符标记所有符合该模式的为外部（external）。
      例如，你可以使用 `*.png` 移除所有的 `.png` 文件或者使用 `/images/*` 移除所有路径以
      `/images/` 开头的路径。当在 外部（external）路径中使用 `*` 通配符时，
      该模式将应用于源代码中的原始路径，而不是解析为实际文件系统路径后的路径。
      这允许你匹配不是真实文件系统路径的路径。

  - h3: Format

  - p: >
      为生成的 JavaScript 文件设置输出格式。有三个可能的值：`iife`、`cjs` 与 `esm`。

  - h4#format-iife: IIFE

  - p: >
      `iife` 格式代表“立即调用函数表达式（immediately-invoked function expression）”并且在浏览器中运行。
      将你的代码包裹在一个函数表达式中，以确保代码中的所有变量不会与全局作用域中的变量冲突。
      如果你的入口起点有你想要暴露在浏览器全局环境中的导出，你可以使用 [global name](#global-name)
      设置 global `iife` 为默认格式，除非你设置 [platform](#platform) 为 `node`。
      像这样使用它：

  - example:
      cli:
        - $: |
            echo 'alert("test")' | esbuild --format=iife
        - expect: |
            (() => {
              alert("test");
            })();

      js: |
        let js = 'alert("test")'
        let out = require('esbuild').transformSync(js, {
          format: 'iife',
        })
        process.stdout.write(out.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "alert(\"test\")"

          result := api.Transform(js, api.TransformOptions{
            Format: api.FormatIIFE,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h4#format-commonjs: CommonJS

  - p: >
      `cjs` 格式打包代表"CommonJS" 并且在 node 环境中运行。它假设环境包括 `exports`、
      `require` 与 `module`。在 ECMAScript 模块语法中带有导出的入口点将被转换为一个模块，
      每个导出名称的 “exports” 上都有一个 getter。当你设置 [platform](#platform) 为 `node` 时，
      `cjs` 为默认格式。像这样使用它：

  - example:
      cli:
        - $: |
            echo 'export default "test"' | esbuild --format=cjs
        - expect: |
            ...
            __export(exports, {
              default: () => stdin_default
            });
            var stdin_default = "test";

      js: |
        let js = 'export default "test"'
        let out = require('esbuild').transformSync(js, {
          format: 'cjs',
        })
        process.stdout.write(out.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "export default 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format: api.FormatCommonJS,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h4#format-esm: ESM

  - p: >
      `esm` 格式代表 "ECMAScript module"。它假设环境支持 `import` 与 `export` 语法。
      在 CommonJS 模块语法中带有导出的入口点将被转换为 `module.exports` 值的单个 `default` 导出。
      像这样使用它：

  - example:
      cli:
        - $: |
            echo 'module.exports = "test"' | esbuild --format=esm
        - expect: |
            ...
            var require_stdin = __commonJS((exports, module) => {
              module.exports = "test";
            });
            export default require_stdin();

      js: |
        let js = 'module.exports = "test"'
        let out = require('esbuild').transformSync(js, {
          format: 'esm',
        })
        process.stdout.write(out.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format: api.FormatESModule,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      `esm` 格式可以在浏览器或者 node 中使用。但是你必须显式地以模块加载它。
      如果你从其他模块 `import`，那么这是自动进行的。否则：

  - ul:
    - >
      在浏览器中，你可以使用 <code>&lt;script <wbr>src="<wbr>file.js" <wbr>type="<wbr>module"&gt;<wbr>&lt;/script&gt;</code> 加载模块。
      <br>&nbsp; 

    - >
      在 node 环境中，你可以使用 <code>node <wbr>--experimental-<wbr>modules <wbr>file.mjs</code> 加载模块。
      请注意 node 需要 `.mjs` 拓展名，除非你在 `package.json` 文件中配置了 <code>"type": <wbr>"module"</code> 。
      你可以使用 esbuild 中的 [out extension](#out-extension) 设置来自定义生成文件的拓展名。
      你可以点击 [这里](https://nodejs.org/api/esm.html) 获取更多关于使用 ECMAScript modules 的内容。

  - h3: Inject

  - p: >
      这个配置项可以自动替换从另一个文件引入的全局变量。
      当你为无法控制的代码适配新环境时是非常有用的。
      例如，假定你有一个叫做 `process-shim.js` 的文件，该文件导出了 `process` 变量：

  - pre.js: |
      // process-shim.js
      export let process = {
        cwd: () => ''
      }

  - pre.js: |
      // entry.js
      console.log(process.cwd())

  - p: >
      这尝试替换 node 的 `process.cwd()` 函数的使用，以阻止包在浏览器中运行它而导致崩溃。
      你可以使用 inject 特性将一个 import 置于文件中以替换所有的全局标识符 `process`。

  - example:
      in:
        process-shim.js: 'export let process = { cwd: () => "" }'
        entry.js: 'console.log(process.cwd())'

      cli: |
        esbuild entry.js --bundle --inject:./process-shim.js --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['entry.js'],
          bundle: true,
          inject: ['./process-shim.js'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"entry.js"},
            Bundle:      true,
            Inject:      []string{"./process-shim.js"},
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      结果是这样的：

  - pre.js: |
      // out.js
      let process = {cwd: () => ""};
      console.log(process.cwd());

  - h4: inject 与 [define](#define) 一起使用

  - p: >
      你可以与 [define](#define) 特性结合使用，这样你的导入会更具可选择性。例如：

  - pre.js: |
      // process-shim.js
      export function dummy_process_cwd() {
        return ''
      }

  - pre.js: |
      // entry.js
      console.log(process.cwd())

  - p: >
      You can map `process.cwd` to `dummy_process_cwd` with the [define](#define)
      feature, then inject `dummy_process_cwd` from `process-shim.js` with the
      inject feature:

  - example:
      in:
        process-shim.js: 'export function dummy_process_cwd() { return "" }'
        entry.js: 'console.log(process.cwd())'

      cli: |
        esbuild entry.js --bundle --define:process.cwd=dummy_process_cwd --inject:./process-shim.js --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['entry.js'],
          bundle: true,
          define: { 'process.cwd': 'dummy_process_cwd' },
          inject: ['./process-shim.js'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"entry.js"},
            Bundle:      true,
            Define: map[string]string{
              "process.cwd": "dummy_process_cwd",
            },
            Inject:  []string{"./process-shim.js"},
            Outfile: "out.js",
            Write:   true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      结果如下：

  - pre.js: |
      // out.js
      function dummy_process_cwd() {
        return "";
      }
      console.log(dummy_process_cwd());

  - h4: 自动导入 [JSX](/content-types/#jsx)

  - p: >
      你可以使用 inject 特性以自动提供 JSX 表达式的执行环境。例如，你可以自动导入 `react`
      包以执行诸如 `React.createElement` 的函数。查看
      [JSX 文档](/content-types/#auto-import-for-jsx) 获取更多。

  - h4: 不使用 import 注入文件

  - p: >
      你可以对不包含 exports 的文件使用该特性。在这种情况下，注入的文件就像每个输入文件都包含
      <code>import <wbr>"./file.js"</code> 一样出现在输出的前面。
      由于 ECMAScript 模块的工作方式，这个注入仍然是 “卫生的”，因为在不同文件中具有相同名称的符号会被重命名，
      这样它们就不会相互冲突。

  - h4: 选择性注入文件

  - p: >
      如果你仅想当导出被实际使用的情况下 _有条件_ 的引入一个文件，你应该通过将其置于 package 中并且
      在 `package.json` 中添加 <code>"sideEffects": <wbr>false</code> 以标记被注入的文件没有副作用。
      该设置为
      [Webpack 公约](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free)，
      esbuild 中该公约对所有的导入文件生效，而不仅仅是注入文件。

  - h3: Loader

  - p: >
      该配置项改变了输入文件解析的方式。例如， [`js`](/content-types/#javascript) loader 将文件解析为 JavaScript，
      [`css`](/content-types/#css) loader 将文件解析为 CSS。查看 [content types](/content-types/) 获取内置
      loader 的完整列表。

  - p: >
      配置一个给定文件类型的 loader 可以让你使用 `import` 声明或者 `require` 调用来加载该文件类型。
      例如，使用 [data URL](/content-types/#data-url) loader 配置 `.png` 文件拓展名，
      这意味着导入 `.png` 文件会给你一个包含该图像内容的数据 URL：

  - pre.js: |
      import url from './example.png'
      let image = new Image
      image.src = url
      document.body.appendChild(image)

      import svg from './example.svg'
      let doc = new DOMParser().parseFromString(svg, 'application/xml')
      let node = document.importNode(doc.documentElement, true)
      document.body.appendChild(node)

  - p: >
      以上代码可以使用 [build API](#build-api) 调用进行打包，就像这样：

  - example:
      in:
        app.js: |
          import url from './example.png'
          let image = new Image
          image.src = url
          document.body.appendChild(image)

          import svg from './example.svg'
          let doc = new DOMParser().parseFromString(svg, 'application/xml')
          let node = document.importNode(doc.documentElement, true)
          document.body.appendChild(node)

        example.png: |
          this is some data

        example.svg: |
          this is some data

      cli: |
        esbuild app.js --bundle --loader:.png=dataurl --loader:.svg=text

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          loader: {
            '.png': 'dataurl',
            '.svg': 'text',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Loader: map[string]api.Loader{
              ".png": api.LoaderDataURL,
              ".svg": api.LoaderText,
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      如果你在 [标准化输入（stdin）](#stdin) 中使用 build API，该配置项就会变的不同，
      因为标准化输入（stdin）没有文件拓展名。使用 build API 为标准化输入（stdin）配置一个 loader，
      就像这样：

  - example:
      in:
        pkg.js: |
          module.exports = 123

      cli: |
        echo 'import pkg = require("./pkg")' | esbuild --loader=ts --bundle

      js: |
        require('esbuild').buildSync({
          stdin: {
            contents: 'import pkg = require("./pkg")',
            loader: 'ts',
            resolveDir: __dirname,
          },
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "log"
        import "os"

        func main() {
          cwd, err := os.Getwd()
          if err != nil {
            log.Fatal(err)
          }

          result := api.Build(api.BuildOptions{
            Stdin: &api.StdinOptions{
              Contents:   "import pkg = require('./pkg')",
              Loader:     api.LoaderTS,
              ResolveDir: cwd,
            },
            Bundle: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      [transform API](#transform-api) 调用仅使用一个 loader，因为它不涉及与文件系统的交互，
      因此不需要处理文件拓展名。为 transform API 配置一个 loader（在这里是
      [`ts`](/content-types/#typescript) loader），就像这样：

  - example:
      cli:
        - $: |
            echo 'let x: number = 1' | esbuild --loader=ts
        - expect: |
            let x = 1;

      js:
        - $: |
            let ts = 'let x: number = 1'
        - $: |
            require('esbuild').transformSync(ts, {
              loader: 'ts',
            })
        - expect: |
            {
              code: 'let x = 1;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          ts := "let x: number = 1"

          result := api.Transform(ts, api.TransformOptions{
            Loader: api.LoaderTS,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Minify

  - p: >
      启用该配置时，生成的代码会被压缩而不是格式化输出。
      压缩后的代码与未压缩代码是相等的，但是会更小。这意味着下载更快但是更难调试。
      一般情况下在生产环境而不是开发环境压缩代码。

  - p: >
      在 esbuild 中这样启用压缩：

  - example:
      cli:
        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify
        - expect: |
            fn=n=>n.x;

      js:
        - $: |
            var js = 'fn = obj => { return obj.x }'
        - $: |
            require('esbuild').transformSync(js, {
              minify: true,
            })
        - expect: |
            {
              code: 'fn=n=>n.x;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "fn = obj => { return obj.x }"

          result := api.Transform(js, api.TransformOptions{
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      该配置项结合起来做三件独立的事情：移除空格、重写语法使其更体积更小、重命名变量为更短的名称。
      一般情况下这三件事情你都想做，但是如果有必要的话，这些配置项可以单独启用：

  - example:
      cli:
        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify-whitespace
        - expect: |
            fn=obj=>{return obj.x};

        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify-identifiers
        - expect: |
            fn = (n) => {
              return n.x;
            };

        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify-syntax
        - expect: |
            fn = (obj) => obj.x;

      js:
        - $: |
            var js = 'fn = obj => { return obj.x }'

        - $: |
            require('esbuild').transformSync(js, {
              minifyWhitespace: true,
            })
        - expect: |
            {
              code: 'fn=obj=>{return obj.x};\n',
              map: '',
              warnings: []
            }

        - $: |
            require('esbuild').transformSync(js, {
              minifyIdentifiers: true,
            })
        - expect: |
            {
              code: 'fn = (n) => {\n  return n.x;\n};\n',
              map: '',
              warnings: []
            }

        - $: |
            require('esbuild').transformSync(js, {
              minifySyntax: true,
            })
        - expect: |
            {
              code: 'fn = (obj) => obj.x;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          css := "div { color: yellow }"

          result1 := api.Transform(css, api.TransformOptions{
            Loader:           api.LoaderCSS,
            MinifyWhitespace: true,
          })

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(css, api.TransformOptions{
            Loader:            api.LoaderCSS,
            MinifyIdentifiers: true,
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }

          result3 := api.Transform(css, api.TransformOptions{
            Loader:       api.LoaderCSS,
            MinifySyntax: true,
          })

          if len(result3.Errors) == 0 {
            fmt.Printf("%s", result3.Code)
          }
        }

  - p: >
      这些概念同样适用于 CSS，而不仅仅是 JavaScript：

  - example:
      cli:
        - $: |
            echo 'div { color: yellow }' | esbuild --loader=css --minify
        - expect: |
            div{color:#ff0}

      js:
        - $: |
            var css = 'div { color: yellow }'
        - $: |
            require('esbuild').transformSync(css, {
              loader: 'css',
              minify: true,
            })
        - expect: |
            {
              code: 'div{color:#ff0}\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          css := "div { color: yellow }"

          result := api.Transform(css, api.TransformOptions{
            Loader:            api.LoaderCSS,
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      esbuild 中的 JavaScript 压缩算法生成的输出通常与行业标准 JavaScript 压缩工具生成的输出大小相近。
      [benchmark](https://github.com/privatenumber/minification-benchmarks/tree/cd3e5acb8d38da5f86426d44ac95974812559683#readme)
      有一个不同压缩工具之间的样例对比。尽管 esbuild 不是所有场景下的最优 JavaScript 压缩工具，
      它努力在专用缩小工具的几个百分点内为大多数代码生成缩小的输出，当然也比其他工具快得多。

  - h4#minify-considerations: 思考

  - p: >
      当时用 esbuild 作为压缩器时需要记住以下几点：

  - ul:
    - >
      <p>
      当启用压缩时也可能也需要设置 [target](#target) 配置项 。默认情况下，
      esbuild 利用现代 JavaScript 特性使你的代码变得更小。例如，
      <code>a ===<wbr> undefined<wbr> || a ===<wbr> null<wbr> ? 1 : a</code>
      可以被压缩为 <code>a ?? 1</code>。如果你不想让 esbuild 在压缩是利用现代 JavaScript 特性，
      你应该使用一个更老的语言目标，例如 <code>--target=es6</code>。
      </p>

    - >
      <p>
      对于所有的 JavaScript 代码，压缩不是 100% 安全的。这对 esbuild 和其他流行的
      JavaScript 压缩器例如[terser](https://github.com/terser/terser) 是真实存在的。
      特别地，esbuild 并不是为了保存函数上调用 `.toString()` 的值而设计的。
      原因是如果所有函数中的所有代码都要逐字保存的话，压缩会变得非常困难并且实际上是没有用的。
      然而，这意味着依赖于 `.toString()` 返回值的 JavaScript 代码在压缩过程中可能会中断。
      例如，在 [Angular](https://angular.io/) 框架中一些模式在代码压缩时会中断，因为 Angular
      使用 `.toString()` 来读取函数的参数名称。一个解决方案是不要使用这些模式。
      </p>

    - >
      <p>
      默认情况下，esbuild 不会在函数和类对象上保留 `.name` 的值。这是因为大多数代码不会依赖该属性，
      并且使用更短的名称是一个重要的大小优化。然而，一些代码确实依赖 `.name` 属性来注册和绑定。
      如果你需要依赖该属性，你应该启用 [keep names](#keep-names) 配置项。
      </p>

    - |
      <p>
      使用某些 JavaScript 特性可以禁用 esbuild 的许多优化，包括压缩。
      具体来说，直接使用 `eval` 和/或 `with` 语句可以阻止 esbuild 将标识符重命名为更小的名称，
      因为这些特性会导致标识符绑定在运行时而不是编译时发生。
      这几乎总是无意的，而且只发生在人们不知道什么是直接 eval 以及它为什么不好的情况下。
      </p>
      <p>
      如果你正在考虑像这样写一段代码：
      </p>
      <pre>
      // 直接使用 eval （将会禁用整个文件的压缩）
      let result = eval(something)
      </pre>
      <p>
      你应该这样写，你的代码才能被压缩：
      </p>
      <pre>
      // 间接使用 eval （对周围的代码没有副作用）
      let result = (0, eval)(something)
      </pre>
      <p>
      [这里](/content-types/#direct-eval) 可以获取关于直接使用 `eval` 以及可用选择的更多信息。
      </p>

    - >
      <p>
      esbuild 中的压缩算法还没有进行高级代码优化。特别是，下面的代码优化对 JavaScript 是
      有可能的，但不是由 esbuild 完成的（不是一个详尽的列表）：
      </p>
      <ul>
        <li>消除函数体中的 dead-code</li>
        <li>函数内联</li>
        <li>Cross-statement 常数传播</li>
        <li>对象形状建模</li>
        <li>Allocation sinking</li>
        <li>Method devirtualization</li>
        <li>Symbolic execution</li>
        <li>JSX 表达式提升</li>
        <li>TypeScript 枚举检测和内联</li>
      </ul>
      <p>
      如果你的代码使用的模式要求某些形式的代码优化是紧凑的，或者如果你正在为你的用例搜索最佳的
      JavaScript 压缩算法，您应该考虑使用其他工具。实现这些高级代码优化的一些工具示例包括
      [Terser](https://github.com/terser/terser#readme) 和
      [Google Closure Compiler](https://github.com/google/closure-compiler#readme)。
      </p>

  - h3: Outdir

  - p: >
      该配置项为 build 操作设置输出文件夹。例如，该命令会生成一个名为 `out` 的目录：

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      输出文件夹如果不存在的话将会创建该文件夹，但是当其包含一些文件时不会被清除。
      生成的文件遇到同名文件会进行静默覆盖。如果你想要输出文件夹只包含当前 esbuild 运行生成的文件，
      你应该在运行 esbuild 之前清除输出文件夹。

  - p: >
      如果你的构建有多个入口，且多个入口在单独的文件夹内，目录结构将从所有输入入口点路径中
      [最低的公共祖先](https://en.wikipedia.org/wiki/Lowest_common_ancestor) 目录开始复制到输出目录中。If your build contains multiple entry points in separate directories, the
      例如，这里有两个入口起点 <code>src/<wbr>home/<wbr>index.ts</code> 与
      <code>src/<wbr>about/<wbr>index.ts</code>，输出文件夹将会包含
      <code>home/<wbr>index.js</code> 与 <code>about/<wbr>index.js</code>。
      如果你想要自定义该行为，你应该改变 [outbase directory](#outbase)。

  - h3: Outfile

  - p: >
      该配置项为 build 操作设置输出文件名。这仅在单个入口点时适用。
      如果有多个入口点，你必须适用 [outdir](#outdir) 配置项来制定输出文件夹。
      像这样使用outfile：

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Platform

  - p: >
      默认情况下，esbuild 的打包器为浏览器生成代码。
      如果你打包好的代码想要在 node 环境中运行，你应该设置 platform 为 `node`：

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --platform=node

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          platform: 'node',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Platform:    api.PlatformNode,
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      当 platform 设置为 `browser`（默认值）时：

  - ul:
    - >
      <p>
      默认的输出 [格式](#format) 为 `iife`，将生成的 JavaScript 代码包裹在立即执行函数表达式中，
      以阻止变量泄露到全局作用域中。 
      </p>
    - >
      <p>
      如果一个包在 `package.json` 文件中
      的[`browser`](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211)
      配置配置了一个 map，esbuild 将会使用该 map 替换指定的文件或模块为对浏览器友好的版本。
      例如，例如，一个包可能会用 [`path-browserify`](https://www.npmjs.com/package/path-browserify) 替换
      [`path`](https://nodejs.org/api/path.html)。
      </p>
    - >
      <p>
      [main fields](#main-fields) 设置为 <code>browser,<wbr>module,<wbr>main</code>，
      但是会有一些额外的特殊行为。如果你个包支持 `module` 与 `main`，但是不支持 `browser`，
      那么当使用 `require()` 导入时，将使用 `main` 而不是 `module`。
      此行为通过将函数赋值给 `module.exports` 来改善与导出函数的 CommonJS 模块的兼容性。
      </p>
    - >
      <p>
      [conditions](#conditions) 设置自动包含了 `browser` 情况。
      这将改变 `package.json` 文件中 `exports` 字段如何被解释为偏好特定于浏览器代码的方式。
      </p>
    - >
      <p>
      为了避免在通过 Browserify 生成的代码中使用 `require` 产生警告，
      特定表达式 <code>typeof <wbr>require <wbr>== <wbr>'function' <wbr>&& <wbr>require</code>
      会被替换为 `false`。这段代码会在已经发布到 npm 的一些包中出现。
      </p>

  - p: >
      当 platform 设置为 `node` 时：

  - ul:
    - >
      <p>
      默认输出 [格式](#format) 为 `cjs`，代表 CommonJS（node 使用的模块格式）。
      ES6-风格的导出使用的 `export` 语句将会被转换为 CommonJS `exports` 对象中的 getters。
      </p>
    - >
      <p>
      所有诸如 `fs` 的 [内置 node 模块](https://nodejs.org/docs/latest/api/) 会被自动标记为
      [external](#external)，因此在打包器尝试打包他们时不会导致错误。
      </p>
    - >
      <p>
      [main 字段](#main-fields) 设置为 <code>main,<wbr>module</code>。
      这意味着 tree shaking 操作可能不会发生在同时提供 `module` 和 `main` 的包中，
      因为 tree shaking 操作只适用于 ECMAScript 模块，而不适用于 CommonJS 模块。
      </p>
      <p>
      不幸的是，一些包将 `module` 视为 "browser code" 而不是 "ECMAScript module code"，
      因此，这种默认行为是兼容性所必需的。如果你想要启用 tree shaking 并且知道这样做是安全的，
      那么你可以手动将 [main 字段](#main-fields) 设置为 <code>module,<wbr>main</code>。
      </p>
    - >
      <p>
      [conditions](#conditions) 设置自动包含 `node` 情况。
      这将改变 `package.json` 文件中 `exports` 字段如何被解释为偏好特定于 node 端代码的方式。
      </p>

  - p: >
      当 platform 设置为 `neutral` 时：

  - ul:
    - >
      <p>
      默认输出 [格式](#format) 为 `esm`，使用 ECMAScript 2015 (即 ES6) 中引入的 `export` 语法。
      如果默认值不合适的话你可以改变输出格式。
      </p>
    - >
      <p>
      [main 字段](#main-fields) 默认设置为空。如果你想使用 npm 风格的包，
      你可能需要将其配置为其他内容，比如将 node 使用的 main 字段配置为 `main`。
      </p>
    - >
      <p>
      [conditions](#conditions) 设置不会自动包含任何平台特定值。
      </p>

  - p: >
      可以查看 [为浏览器打包](/getting-started/#bundling-for-the-browser)
      与 [为 node 打包](/getting-started/#bundling-for-node)。

  - h3: Serve

  - p: >
      在开发过程中，当发生更改时在文本编辑器与浏览器之间来回切换是很正常的事。
      在浏览器中重新加载代码之前手动重新运行 esbuild 是很不方便的。有几种方法可以自动完成：

  - ul:
    - 当一个文件发生更改时使用 [监听模式](#watch) 重新运行 esbuild
    - 将你的文本编辑器配置为每次保存代码重新运行 esbuild
    - 使用一个对于每次请求都会重新构建的 web 服务器来为你的代码提供服务

  - p: >
      此 API 调用使用的是最后一种方法。serve API 与 [build API](#build-api) 调用很相似，
      但是它不会将生成的代码写入到文件系统中，它启动一个 long-lived 本地 web 服务器来为最新构建生成的代码提供服务。
      每批新的请求都会导致 esbuild 在响应请求之前重新运行构建命令，这样你的文件就总是最新的。

  - p: >
      此方法对于其他方法的优势在于 web 服务器可以延迟浏览器请求，知道构建完成。
      在最新构建完成之前重新加载你的代码，将永远不会运行上一次构建生成的代码。
      这些文件在内存中提供服务，并且没有写入到文件系统中，以确保过时的文件不会被监听。

  - p: >
      请注意，这仅会在开发环境中使用。_不要将其用在生产环境中。_
      在生产环境中你不应该使用 esbuild 作为一个 web 服务器来服务静态资源。、

  - p: >
      有两个不同的方法来使用 serve API：

  - h4#serve-everything: '方法 1：为 esbuild 构建出的所有内容提供服务'

  - p: >
      通过这种方法，你为 esbuild 提供一个名为 servedir 的目录，除了 esbuild 生成的文件之外，还提供了额外的内容。
      这对于创建一些静态 HTML 页面并希望使用 esbuild 打包 JavaScript 和/或 CSS 的简单情况非常有用。
      你可以把你的 HTML 文件置于 servedir 中，你的其他源代码置于 servedir 之外，
      然后将 [`outdir`](#outdir) 设置为在某处的 servedir：

  - example:
      noCheck: true

      cli: |
        esbuild src/app.js --servedir=www --outdir=www/js --bundle

      js: |
        require('esbuild').serve({
          servedir: 'www',
        }, {
          entryPoints: ['src/app.js'],
          outdir: 'www/js',
          bundle: true,
        }).then(server => {
          // Call "stop" on the web server when you're done
          server.stop()
        })

      go: |
        server, err := api.Serve(api.ServeOptions{
          Servedir: "www",
        }, api.BuildOptions{
          EntryPoints: []string{"src/app.js"},
          Outdir:      "www/js",
          Bundle:      true,
        })

        // Call "stop" on the web server when you're done
        server.Stop()

  - p: >
      在上面的例子中，你的 `www/index.html` 页面可以像这样引用打包好的 `src/app.js` 文件：

  - pre.html: |
      <script src="js/app.js"></script>

  - p: >
      当你这样做时，每一个 HTTP 请求都会导致 esbuild 重新构建你的代码，并且为你提供最新版本的代码。
      因此每次刷新页面，`js/app.js` 文件总是最新的。请注意尽管生成的出现在了 `outdir` 目录中，
      但是它从来没有使用 serve API 真正写入过文件系统。相反，生成的代码映射的路径（即优先于其他路径）
      在 `servedir` 和生成的文件直接从内存提供服务。

  - p: >
      这样做的好处是，你可以使用在开发环境与生产环境使用完全相同的 HTML 页面。
      在开发环境中你可以使用 `--servedir=` 运行 esbuild，esbuild 将会直接为生成的输出文件提供服务。
      在生产环境中，你可以设置该标志，esbuild 将会把生成的文件写入到文件系统中。
      这两种情况下你应该能够在浏览器中得到完全一样的结果，其在开发环境与生产环境中拥有完全相同的代码。

  - p: >
      端口号默认自动设置为大于等于 8000 的一个开放端口。端口号会在 API 调用时返回（或者使用 CLI 时会打印在终端中），
      这样你就可以知道应该访问哪一个 URL。如果有必要的话，端口号可以被指定（下面会详细描述）。

  - h4#serve-generated: '方法 2: 仅为 esbuild 生成的文件提供服务'

  - p: >
      使用该方法，你只需要告诉 esbuild 为 [`outdir`](#outdir) 中的内容提供服务，而不会让其为额外的内容提供服务。
      对比更复杂的开发环境配置是比较有用的。例如，你可能想要在开发环境中使用 NGINX 作为反向代理来路由不同的路径到不同的后端服务
      （例如 `/static/` 转向 NGINX、`/api/` 转向 node、`/js/` 转向 esbuild 等）。
      可以向这样使用 esbuild 的该方法：

  - example:
      noCheck: true

      cli: |
        esbuild src/app.js --outfile=out.js --bundle --serve=8000

      js: |
        require('esbuild').serve({
          port: 8000,
        }, {
          entryPoints: ['src/app.js'],
          bundle: true,
          outfile: 'out.js',
        }).then(server => {
          // Call "stop" on the web server when you're done
          server.stop()
        })

      go: |
        server, err := api.Serve(api.ServeOptions{
          Port: 8000,
        }, api.BuildOptions{
          EntryPoints: []string{"src/app.js"},
          Bundle:      true,
          Outfile:     "out.js",
        })

        // Call "stop" on the web server when you're done
        server.Stop()

  - p: >
      上面示例中的 API 调用会在 [http://localhost:8000/out.js](http://localhost:8000/out.js) 为
      编译好的 `src/app.js` 提供服务。就像是第一个方法，每个 HTTP 请求都会导致 esbuild 重新构建你的代码，
      并且为你提供最新版本的代码。因此 `out.js` 将一直是最新的。你的 HTML 文件（被其他 web 服务器在其他端口上提供服务）
      可以在你的 HTML 文件中像这样关联编译好的文件：

  - pre.html: |
      <script src="http://localhost:8000/out.js"></script>

  - p: >
      在没有启用 web 服务器的情况下，使用正常的构建命令时，web 服务器的 URL 结构与 [输出目录](#outdir) 的URL结构完全相同。
      例如，如果输出输出文件夹包含一个叫做 <code>./pages/<wbr>about.js</code> 的文件，web 服务器将会有一个相应的
      <code>/pages/<wbr>about.js</code> 路径。

  - p: >
      如果你想要浏览 web 服务器以查看哪些 URL 是有效的，你可以通过访问文件夹名称而不是文件名称来使用内置文件夹列表。
      例如，如果你正在 8000 端口运行 esbuild 的 web 服务器，你可以在浏览器中访问
      [http://<wbr>localhost:<wbr>8000/](http://localhost:8000/) 来查看 web 服务器的根目录。
      在这里你可以点击链接在 web 服务器中打开不同的文件或链接。

  - h4#serve-arguments: 参数

  - p: >
      请注意 serve API 是与 [build API](#build-api) 不同的 API 调用。
      这是因为启动一个长时间运行的 web 服务器是完全不同的，因此需要不同的参数和返回值。
      serve API 调用的第一个参数是一个带有特定于 serve 的配置项的配置项对象：

  - example:
      noCheck: true

      js: |
        interface ServeOptions {
          port?: number;
          host?: string;
          servedir?: string;
          onRequest?: (args: ServeOnRequestArgs) => void;
        }

        interface ServeOnRequestArgs {
          remoteAddress: string;
          method: string;
          path: string;
          status: number;
          timeInMS: number;
        }

      go: |
        type ServeOptions struct {
          Port      uint16
          Host      string
          Servedir  string
          OnRequest func(ServeOnRequestArgs)
        }

        type ServeOnRequestArgs struct {
          RemoteAddress string
          Method        string
          Path          string
          Status        int
          TimeInMS      int
        }

  - ul:
    - >
      `port`
      <p>
      可以选择在这里配置 HTTP 端口。如果省略，它将默认使用一个开放端口，优先级为 8000 端口。
      你可以在命令行中通过使用 `--serve=8000` 而不仅仅是 `--serve` 来设置端口。
      </p>

    - >
      `host`
      <p>
      默认情况下，esbuild 在所有的 IPv4 网络接口中有效。
      这对应着 `0.0.0.0` 的 host。如果你想要配置一个不同的 host（例如，仅在 `127.0.0.1` 回路中提供服务而不向网络公开任何信息），
      你可以使用该参数指定 host。你可以在命令行中通过使用 <code>--serve=<wbr>127.0.0.1:<wbr>8000</code>
      而不仅仅是 `--serve` 来设置 host。
      </p>
      <p>
      如果你需要使用 IPv6 而不是 IPv4，你仅需要指定一个 IPv6 host 地址。
      在 IPv6 中与 `127.0.0.1` 回路接口等效的是 `::1`，并且与 `0.0.0.0` 通用接口等效的是 `::`。
      如果你正在使用命令行将 host 设置为 IPv6 地址，您需要用方括号将 IPv6 地址括起来，以区别地址中
      的冒号和分隔主机和端口的冒号，就像这样： <code>--serve=<wbr>[::]:<wbr>8000</code>。
      </p>

    - >
      `servedir`
      <p>
      这是 esbuild 的 HTTP 服务器提供的额外内容目录，当传入的请求与生成的任何输出文件路径不匹配时，它将代替 404。
      这使你可以将 esbuild 用作通用的本地 web 服务器。例如，使用 <code>esbuild <wbr>--servedir=.</code>
      在 `localhost` 为当前文件夹提供服务。在前面关于不同方法的部分中，对使用 `servedir` 进行了更详细的描述。
      </p>

    - >
      `onRequest`
      <p>
      对每个传入的请求调用一次，并提供有关请求的一些信息。
      CLI 使用该回调为每一个请求打印日志信息。time 字段是为该请求生成数据的时间，
      但是它不包括向客户端发送请求流的时间。
      </p>
      <p>
      请注意这会在请求完成后调用。使用该回调以任何形式修改请求是不可能的。
      如果你想要这样做，你应该 [在 esbuild 之前设置一个代理](#customizing-server-behavior)。
      </p>

  - p: >
      serve API 调用的第二个参数是每个请求都会调用的底层构建 API 的常规配置项集合。
      查看 [build API](#build-api) 文档获取更多关于这些配置项的信息。

  - h4#serve-return-values: 返回值

  - example:
      noCheck: true

      js: |
        interface ServeResult {
          port: number;
          host: string;
          wait: Promise<void>;
          stop: () => void;
        }

      go: |
        type ServeResult struct {
          Port uint16
          Host string
          Wait func() error
          Stop func()
        }

  - ul:
    - >
      `port`
      <p>
      这个是最终被 web 服务器使用的端口。如果你没有指定一个端口的话你将想要使用它，因为 esbuild
      将最终挑选一个随机开放端口，并且你需要知道它选择了那个段扩才能连接到它。
      如果你正在使用 CLI，这个端口号将会被打印在终端的 stderr 中。
      </p>

    - >
      `host`
      <p>
      这个是最终被 web 服务器使用的 host。它将是
      `0.0.0.0`（即 服务所有可用的网络接口），除非配置了一个自定义 host。
      </p>

    - >
      `wait`
      <p>
      只要 socket 打开，serve API 调用会立即返回。这个 `wait` 返回值提供了一种方法，可以在 web 服务器
      由于网络错误或者由于将来某个时间点停止调用而终止是通知它。
      </p>

    - >
      `stop`
      <p>
      当你不需要它清理资源时，你可以调用该回调以停止 web 服务器。
      这将会立即终止所有打开的链接，并且唤醒所有等待 `wait` 返回值的代码。
      </p>

  - h4: 自定义服务器行为

  - p: >
      不可能 hook 到 esbuild 的本地服务器来定制服务器本身的行为。
      相反，应该通过在 esbuild 前设置代理来定制行为。

  - p: >
      下面是一个代理服务器的简单示例。
      他添加了自定义 404 页面而不使用 esbuild 的默认 404 页面：

  - pre.js: |
      const esbuild = require('esbuild');
      const http = require('http');

      // Start esbuild's server on a random local port
      esbuild.serve({
        servedir: __dirname,
      }, {
        // ... your build options go here ...
      }).then(result => {
        // The result tells us where esbuild's local server is
        const {host, port} = result

        // Then start a proxy server on port 3000
        http.createServer((req, res) => {
          const options = {
            hostname: host,
            port: port,
            path: req.url,
            method: req.method,
            headers: req.headers,
          }

          // Forward each incoming request to esbuild
          const proxyReq = http.request(options, proxyRes => {
            // If esbuild returns "not found", send a custom 404 page
            if (proxyRes.statusCode === 404) {
              res.writeHead(404, { 'Content-Type': 'text/html' });
              res.end('<h1>A custom 404 page</h1>');
              return;
            }

            // Otherwise, forward the response from esbuild to the client
            res.writeHead(proxyRes.statusCode, proxyRes.headers);
            proxyRes.pipe(res, { end: true });
          });

          // Forward the body of the request to esbuild
          req.pipe(proxyReq, { end: true });
        }).listen(3000);
      });

  - p: >
      该代码在一个随机本地端口启动了 esbuild 服务器，然后在 3000 端口启动了一个代理服务器。
      在开发环境中你可以在浏览器中加载 [http://localhost:3000](http://localhost:3000)，
      这将会走向代理。该示例示范了在 esbuild 已经处理请求之后修改相应信息，但你也可以在 esbuild 处理它之前
      修改或替换请求信息。

  - p: >
      你可以使用代理做很多事情，就像下面的举例：

  - ul:
    - 插入你自己的 404 页面（上面的示例）
    - 自定义路由与文件系统中文件之间的映射关系
    - 重定向一些路由到 API 服务器而不是到 esbuild
    - 使用自签名证书添加 HTTPS 支持

  - p: >
      如果你有更高级的需求的话，你也可以使用诸如 [NGINX](https://nginx.org/en/docs/beginners_guide.html#proxy) 一样真正的代理。

  - h3: Sourcemap

  - p: >
      Source map 可以使调试代码更容易。它们编码从生成的输出文件中的行/列偏移量转换回对应的
      原始输入文件中的行/列偏移量所需的信息。如果生成的代码与原始代码有很大的不同，这是很有用的
      （例如 你的源代码为 Typescript 或者你启用了 [压缩](#minify)）

  - p: >
      启用 source map 将会伴随着任何一个生成的 `.js` 文件生成一个 `.js.map` 文件，并且在
      `.js` 文件底部添加特殊的 `//# sourceMappingURL=` 注释以指向 `.js.map` 文件。

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapLinked,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      如果输入的文件本身包含特殊 `//# sourceMappingURL=` 注释，esbuild 将会自动尝试解析
      链接的 source map。如果成功的话，生成的源映射中的映射将一路映射回输入源映射中引用的原始源代码。

  - p: >
      如果你想在生成的 `.js` 中省略特殊 `//# sourceMappingURL=` 注释，但是你仍想生成 `.js.map` 文件，
      你应该设置 source map 模式为 `external`：

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap=external --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: 'external',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapExternal,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      如果你想插入整个 source map 到 `.js` 文件中而不是单独生成一个 `.js.map` 文件，你应该设置
      source map 模式为 `inline`：

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap=inline --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: 'inline',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapInline,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      请记住 source map 通常是比较大的，因为他们包含所有的源代码，因此你通常不会想让代码中包含
      `inline` source maps。为了移除 source map 中的源代码（只保存文件名以及行/列映射关系），
      请使用 [sources content](#sources-content) 配置项。

  - p: >
      如果你想同时设置 `inline` 与 `external` 的话，你应该设置 source map 模式为 `both`：

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap=both --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: 'both',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapInlineAndExternal,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h4: 使用 source maps

  - p: >
      在浏览器中，source maps 应该会自动被浏览器开发者工具选中，只要其启用了 source map 设置。
      请注意浏览器仅在堆栈跟踪打印在控制台后才会使用 source maps。堆栈跟踪本身没有修改，所以检查 <code>error.<wbr>stack</code>。
      你代码中的堆栈仍然会给出包含已编译代码的未映射堆栈跟踪。
      这里是如何启用浏览器开发者工具中 source map 设置的方式：

  - ul:
      - 'Chrome: ⚙ → Enable JavaScript source maps'
      - 'Safari: ⚙ → Sources → Enable source maps'
      - 'Firefox: ··· → Enable Source Maps'

  - p: >
      在 node 环境中，source map 在 [version v12.12.0](https://nodejs.org/en/blog/release/v12.12.0/) 版本之后原生支持。
      此特性是默认关闭的，但是可以通过一个标志启用。不向在浏览器中，实际的堆栈跟踪也被修改了，所以检查你代码中的 <code>error.<wbr>stack</code>
      将会给出包含源代码的堆栈跟踪。这是如何在 node 中启用该设置（<code>--enable-<wbr>source-<wbr>maps</code> 标志
      必须在文件名之前）：

  - pre.sh: |
      node --enable-source-maps app.js

  - h3: 代码分割

  - warning: >
      代码分隔仍然处于开发状态。它现在仅支持 `esm` 输出 [格式](#format)。
      使用 `import` 语句来分割代码块也有一个已知的
      [排序问题](https://github.com/evanw/esbuild/issues/399) 。你可以关注
      [跟踪问题](https://github.com/evanw/esbuild/issues/16) 获取此特性的更新。

  - p: >
      启用 "代码分隔" 有两个目的：

  - ul:
      - >
        <p>
        多个入口点之间共享的代码被分割成两个入口点都导入的单独共享文件。
        这样，如果用户先浏览一个页面，然后再浏览另一个页面，如果共享部分已经被浏览器下载并缓存，
        他们就不必从头下载第二个页面的所有 JavaScript。
        </p>

      - >
        <p>
        通过异步 `import()` 表达式引用的代码将被分割到一个单独的文件中，
        仅在求值该表达式时才加载。这允许你通过在启动时只下载你需要的代码来改善应用程序的初始下载时间，
        然后在以后需要时延迟下载额外的代码。
        </p>
        <p>
        如果不启用代码分割，`import()` 表达式会变成
        <code>Promise<wbr>.resolve()<wbr>.then(() =&gt; <wbr>require())</code>。
        这仍然保留了表达式的异步语义，但这意味着导入的代码包含在同一个包中，而不是分离到单独的文件中。
        </p>

  - p: >
      当期启用代码分割时，你必须使用 [outdir](#outdir) 配置输出文件夹。

  - example:
      in:
        home.ts: '1 + 2'
        about.ts: '1 + 2'

      cli: |
        esbuild home.ts about.ts --bundle --splitting --outdir=out --format=esm

      js: |
        require('esbuild').buildSync({
          entryPoints: ['home.ts', 'about.ts'],
          bundle: true,
          splitting: true,
          outdir: 'out',
          format: 'esm',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"home.ts", "about.ts"},
            Bundle:      true,
            Splitting:   true,
            Outdir:      "out",
            Format:      api.FormatESModule,
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Target

  - p: >
      此配置项设置生成 JavaScript 代码的目标环境。例如，你可以配置 esbuild 不要生成任何
      v10 版本的 node 不能处理的新的 JavaScript 代码。target 可以设置为类似于 `es2020`
      的 JavaScript 语言版本，或者一个引擎列表（目前可以是 `chrome`、`firefox`、`safari`、`edge`
      或者 `node`）。默认的 target 为 `esnext`，这意味着默认情况下，esbuild 将假设所有最新的 JavaScript
      特性都是受支持的。

  - p: >
      这里是在 esbuild 中使用所有可用 target 环境名称的例子。请注意你不需要指定所有这些；
      你可以仅仅指定你的项目关心的目标环境的子集。如果你愿意的话，你也可以更精确地描述版本号
      （例如 设置为 `node12.19.0` 而不仅仅是 `node12`）：

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --target=es2020,chrome58,firefox57,safari11,edge16,node12

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          target: [
            'es2020',
            'chrome58',
            'firefox57',
            'safari11',
            'edge16',
            'node12',
          ],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Target:      api.ES2020,
            Engines: []api.Engine{
              {Name: api.EngineChrome, Version: "58"},
              {Name: api.EngineFirefox, Version: "57"},
              {Name: api.EngineSafari, Version: "11"},
              {Name: api.EngineEdge, Version: "16"},
              {Name: api.EngineNode, Version: "12"},
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      你可以参考 [JavaScript loader](/content-types/#javascript) 获取更多关于哪个
      语言版本引入了哪些语法特性。请记住尽管像 `es2020` 的 JavaScript 语言版本是以年定义的，
      这是该规范被批准的年份。这与所有主流浏览器实现该规范的年份无关，因为实现该规范的时间往往
      早于或晚于那一年。

  - p: >
      请注意如果你使用了一个语法特性，esbuild 还不支持将其转为目标语言 target，esbuild 将会
      在不支持的语法位置生成一个错误。例如，当目标是 `es5` 语言版本时，经常会出现这种情况，
      因为 esbuild 只支持将大多数较新的 JavaScript 语法特性转换为 `es6`。

  - h3: Watch

  - p: >
      在 build API 中启用监听模式，告诉 esbuild 监听文件系统中的变化，并在可能导致构建失效的
      文件更改时重新构建。像这样使用它：

  - example:
      noCheck: true

      cli: |
        esbuild app.js --outfile=out.js --bundle --watch

      js: |
        require('esbuild').build({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
          watch: true,
        }).then(result => {
          // Call "stop" on the result when you're done
          result.stop()
        })

      go: |
        result := api.Build(api.BuildOptions{
          EntryPoints: []string{"app.js"},
          Outfile:     "out.js",
          Bundle:      true,
          Watch:       &api.WatchMode{},
        })

        // Call "stop" on the result when you're done
        result.Stop()

  - p: >
      如果你正在使用 JavaScript 或者 Go API，你可以选择性地提供一个回调函数，该函数将会在
      增量构建完成后调用。一旦构建完成，就可以使用它来做一些事情（例如 重新加载浏览器中的应用）：

  - example:
      noCheck: true

      js: |
        require('esbuild').build({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
          watch: {
            onRebuild(error, result) {
              if (error) console.error('watch build failed:', error)
              else console.error('watch build succeeded:', result)
            },
          },
        }).then(result => {
          // Call "stop" on the result when you're done
          result.stop()
        })

      go: |
        result := api.Build(api.BuildOptions{
          EntryPoints: []string{"app.js"},
          Outfile:     "out.js",
          Bundle:      true,
          Watch: &api.WatchMode{
            OnRebuild: func(result api.BuildResult) {
              if len(result.Errors) > 0 {
                fmt.Printf("watch build failed: %d errors\n", len(result.Errors))
              } else {
                fmt.Printf("watch build succeeded: %d warnings\n", len(result.Warnings))
              }
            },
          },
        })

        // Call "stop" on the result when you're done
        result.Stop()

  - p: >
      为了实现可移植性，esbuild 中的监视模式使用轮询而不是特定于操作系统的文件系统 api 来实现的。
      与一次扫描整个目录树的更传统的轮询系统相比，轮询系统被设计为使用相对较少的 CPU。
      仍然会定期扫描文件系统，但每次扫描只检查文件的随机子集，这意味着在更改之后，文件的更改将很
      快被发现，但不一定是立即发现。

  - p: >
      使用当前的启发式方法，大型项目应该每 2 秒完全扫描一次，因此在最坏的情况下，可能需要 2 秒才能注意到变化。
      然而，在注意到变更后，变更的路径会出现在最近变更的路径的短列表中，每次扫描都会检查这些路径，所以对最近
      变更的文件的进一步变更应该几乎立即被注意到。

  - p: >
      请注意，如果你不想使用基于轮询的方法，你可以使用 esbuild 的 [增量构建 API](#incremental) 跟一个
      你选择的文件监听器来实现监听模式。

  - h3: Write

  - p: >
      build API 可以写入文件系统中，也可以返回本应作为内存缓冲区写入的文件。默认情况下 CLI 与 JavaScript API
      写入到文件系统，GO API 不是。使用内存缓冲区：

  - example:
      in:
        app.js: '1 + 2'

      js: |
        let result = require('esbuild').buildSync({
          entryPoints: ['app.js'],
          sourcemap: 'external',
          write: false,
          outdir: 'out',
        })

        for (let out of result.outputFiles) {
          console.log(out.path, out.contents)
        }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Sourcemap:   api.SourceMapExternal,
            Write:       false,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          for _, out := range result.OutputFiles {
            fmt.Printf("%v %v\n", out.Path, out.Contents)
          }
        }

  - h2: 高级配置

  - h3: 资源名称

  - p: >
      当 [loader](#loader) 设置为 [`file`](/content-types/#external-file) 时，该配置项
      控制额外生成的文件名称。它使用带有占位符的模板来配置输出路径，当生成输出路径时，占位符将被特定
      于文件的值替换。例如，例如，指定 <code>assets/<wbr>[name]-<wbr>[hash]</code> 的资源名
      称模板，将所有资源放入输出目录内名为 `assets` 的子目录中，并在文件名中包含资产的内容哈希。
      像这样使用它：

  - example:
      in:
        app.js: 'import "./file.png"'
        file.png: 'a png file'

      cli: |
        esbuild app.js --asset-names=assets/[name]-[hash] --loader:.png=file --bundle --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          assetNames: 'assets/[name]-[hash]',
          loader: { '.png': 'file' },
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            AssetNames:  "assets/[name]-[hash]",
            Loader: map[string]api.Loader{
              ".png": api.LoaderFile,
            },
            Bundle: true,
            Outdir: "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      在资源路径模板中有两个可用占位符：

  - ul:
    - >
      `[name]`
      <p>
      这是不带拓展名的原始资源文件名称。例如，如果一个资源原来名为 `image.png`，然后模板中的
      `[name]` 就会被 `image` 替换。没有必要使用该占位符；它的存在只是为了提供对人类友好的资源
      名称，使调试更容易。
      </p>

    - >
      `[hash]`
      <p>
      这是资源的内容哈希，可以避免命名冲突。例如，你的代码可能会导入 <code>components/<wbr>button/<wbr>icon.png</code>
      和 <code>components/<wbr>select/<wbr>icon.png</code> ，在这种情况下，
      你需要使用哈希值来区分这两个都命名为 icon 的资源。
      </p>

  - p: >
      资源路径模板不需要包含文件拓展名。资源的原始拓展名将会在模板替换完成后添加到输出路径尾部。

  - p: >
      该配置项与 [chunk 名称](#chunk-names) 与 [入口名称](#entry-names) 相似。

  - h3: Banner

  - p: >
      使用它可以在生成的 JavaScript 和 CSS 文件的开头插入任意字符串。这一般被用来插入注释：

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --banner:js=//comment --banner:css=/*comment*/

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          banner: {
            js: '//comment',
            css: '/*comment*/',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Banner: map[string]string{
              "js":  "//comment",
              "css": "/*comment*/",
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      这与 [footer](#footer) 很相似，只不过它是在末尾插入而不是开头。

  - p: >
      请注意如果你在 CSS 文件中插入了一段非注释代码，CSS 会忽略 non-`@import` 规则后面的 `@import`
      规则（`@charset` 规则除外），所以使用 Banner 来注入 CSS 规则可能会意外地禁用外部样式表的导入。

  - h3: Charset

  - p: >
      默认情况下 esbuild 的输出是 ASCII-only。任何非 ASCII 字符都使用反斜杠转义序列进行转义。
      原因是默认情况下，非 ASCII 字符会被浏览器误读，导致混淆。你必须在你的 HTML 文件中明确添加
      <code>&lt;meta <wbr>charset=<wbr>"utf-8"&gt;</code>，或者为他提供正确的 <code>Content-<wbr>Type</code>
      头，以便浏览器不会损坏代码。另一个原因是，非 ASCII 字符会显著 [降低浏览器解析器的速度](https://v8.dev/blog/scanner)。
      然而，使用转义序列会使生成的输出稍微大一些，也会使其更难阅读。

  - p: >
      如果你想让 esbuild 在不使用转义序列的情况下打印原始字符，并且你已经确保浏览器将你的代码解释为 UTF-8，
      你可以通过设置字符集来禁用字符转义：

  - example:
      cli:
        - $: |
            echo 'let π = Math.PI' | esbuild
        - expect: |
            let \u03C0 = Math.PI;
        - $: |
            echo 'let π = Math.PI' | esbuild --charset=utf8
        - expect: |
            let π = Math.PI;

      js:
        - $: |
            let js = 'let π = Math.PI'
        - $: |
            require('esbuild').transformSync(js)
        - expect: |
            {
              code: 'let \\u03C0 = Math.PI;\n',
              map: '',
              warnings: []
            }
        - $: |
            require('esbuild').transformSync(js, {
              charset: 'utf8',
            })
        - expect: |
            {
              code: 'let π = Math.PI;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "let π = Math.PI"

          result1 := api.Transform(js, api.TransformOptions{})

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(js, api.TransformOptions{
            Charset: api.CharsetUTF8,
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }
        }

  - p: >
      一些警告：

  - ul:
    - >
      <p>
      这还不会转义嵌入在正则表达式中的非 ASCII 字符。这是因为 esbuild 目前根本不解析正则表达式的内容。
      尽管有这个限制，但还是添加了这个标志，因为它对于不包含这种情况的代码仍然有用。
      </p>
    - >
      <p>
      此标志不适用于注释。我认为在注释中保留非 ASCII 数据应该没有问题，因为即使编码是错误的，
      运行时环境也应该完全忽略所有注释的内容。例如，[V8 的博文](https://v8.dev/blog/scanner) 
      提到了一种优化，可以完全避免对评论内容进行解码。esbuild 会剔除除与许可相关的所有注释。
      </p>
    - >
      <p>
      此选项同时适用于所有输出文件类型（JavaScript、CSS 和 JSON）。因此，如果你配置你的 web 
      服务器发送正确的 <code>Content-<wbr>Type</code> 头，并希望使用 UTF-8 字符集，
      请确保你的 web 服务器配置为将 `.js` 和 `.css`文件都作为 UTF-8 处理。
      </p>

  - h3: Chunk 名称

  - p: >
      此选项控制在启用 [代码分割](#splitting) 时自动生成的共享代码块的文件名。
      它使用带有占位符的模板来配置输出路径，当生成输出路径时，占位符将被特定于 chunk 的值替换。
      例如，指定 <code>chunks/<wbr>[name]-<wbr>[hash]</code> 的 chunk 名称模板，
      将所有生成的块放入输出目录内的名为 `chunks` 的子目录中，并在文件名中包含 chunk 的内容哈希。
      像这样使用它：

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --chunk-names=chunks/[name]-[hash] --bundle --outdir=out --splitting --format=esm

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          chunkNames: 'chunks/[name]-[hash]',
          bundle: true,
          outdir: 'out',
          splitting: true,
          format: 'esm',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            ChunkNames:  "chunks/[name]-[hash]",
            Bundle:      true,
            Outdir:      "out",
            Splitting:   true,
            Format:      api.FormatESModule,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      在 chunk 路径模板中有两个可用占位符：

  - ul:
    - >
      `[name]`
      <p>
      目前这将始终是 `chunk`，尽管这个占位符在将来的版本中可能会有额外的值。
      </p>

    - >
      `[hash]`
      <p>
      这是 chunk 的内容哈希。在生成多个共享代码块的情况下，内容哈希是区分不同 chunk 的必要条件。
      </p>

  - p: >
      chunk 路径模板不需要包括一个文件拓展名。在模板替换之后，为适当内容类型配置的 
      [out extension](#out-extension) 将自动添加到输出路径的末尾。

  - p: >
      注意，这个配置项只控制自动生成的共享代码块的名称。它 _不_ 控制与入口点相关的输出文件的名称。
      它们的名称目前是从相对于 [outbase](#outbase) 目录的原始入口点文件的路径确定的，且无法更改此行为。
      将来会添加一个额外的API选项，允许你更改入口点输出文件的文件名。

  - p: >
      该配置项与 [资源名称](#asset-names) 和 [入口名称](#entry-names) 相似。

  - h3: 颜色

  - p: >
      该配置项启用或禁用 esbuild 写入终端中的 stderr 文件描述符中的错误和警告消息中的颜色。
      默认情况下，如果 stderr 是一个 TTY 会话，颜色将自动启用，否则将自动禁用。
      esbuild 中有颜色的输出就像是这样：

  - pre.raw: |
      <b> &gt; example.js: <span class="color-red">error:</span> Could not resolve "logger" (mark it as external to exclude it from the bundle)</b>
      <span class="color-dim">    1 │ import log from </span><span class="color-green">"logger"</span>
      <span class="color-dim">      ╵                 </span><span class="color-green">~~~~~~~~</span>

      <b> &gt; example.js: <span class="color-purple">warning:</span> The "typeof" operator will never evaluate to "null"</b>
      <span class="color-dim">    2 │ log(typeof x == </span><span class="color-green">"null"</span><span class="color-dim">)</span>
      <span class="color-dim">      ╵                 </span><span class="color-green">~~~~~~</span>

      1 warning and 1 error

  - p: >
      将 color 设置为 `true` 可以强制启用有颜色的输出。
      如果你自己把 esbuild 的 stderr 输出管道到 TTY 中，这是很有用的：

  - example:
      cli: |
        echo 'typeof x == "null"' | esbuild --color=true 2> stderr.txt

      js: |
        let js = 'typeof x == "null"'
        require('esbuild').transformSync(js, {
          color: true,
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "typeof x == 'null'"

          result := api.Transform(js, api.TransformOptions{
            Color: api.ColorAlways,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      可以将 color 设置为 `false` 以禁用。

  - h3: Conditions

  - p: >
      此特性控制 `package.json` 中的 `exports` 字段是如何被解析的。通过 conditions 设置可以添加自定义条件。
      您可以指定任意数量的包，这些包的含义完全取决于包的作者。Node 目前只认可了推荐使用的 `development` 和
      `production` 定制条件。下面是一个添加自定义条件 `custom1` 和 `custom2` 的示例：

  - example:
      in:
        src/app.js: 'import "pkg"'
        src/node_modules/pkg/package.json: '{ "exports": { "custom1": "./foo.js" } }'
        src/node_modules/pkg/foo.js: 'console.log(123)'

      cli: |
        esbuild src/app.js --bundle --conditions=custom1,custom2

      js: |
        require('esbuild').buildSync({
          entryPoints: ['src/app.js'],
          bundle: true,
          conditions: ['custom1', 'custom2'],
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"src/app.js"},
            Bundle:      true,
            Conditions:  []string{"custom1", "custom2"},
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h4: conditions 是如何工作的

  - p: >
      Conditions 允许你在不同的情况下将相同的导入路径重定向到不同的文件位置。
      包含条件和路径的重定向映射存储在包的 `package.json` 的 exports 字段中。
      例如，在使用 `import` 与 `require` 条件下会重新映射 `require('pkg/foo')` 到 `pkg/required.cjs`，
      `import 'pkg/foo'` 到 `pkg/imported.mjs`：

  - pre.json: |
      {
        "name": "pkg",
        "exports": {
          "./foo": {
            "import": "./imported.mjs",
            "require": "./required.cjs",
            "default": "./fallback.js"
          }
        }
      }

  - p: >
      Conditions 按照它们在 JSON 文件中出现的顺序进行检查。
      所以上面的例子有点像这样：

  - pre.js: |
      if (importPath === './foo') {
        if (conditions.has('import')) return './imported.mjs'
        if (conditions.has('require')) return './required.cjs'
        return './fallback.js'
      }

  - p: >
      默认情况下，esbuild 有五种内置特定行为，并且不能被禁用：
  - ul:
    - >
      `default`
      <p>
      该条件总处于激活状态。它的目的是放在最后，让你在没有其他条件应用时提供兜底。
      </p>
    - >
      `import`
      <p>
      该条件仅在通过 ESM `import` 声明或者 `import()` 表达式导入路径时生效。
      可以用来提供特定于 ESM 的代码。
      </p>
    - >
      `require`
      <p>
      该条件仅在通过 CommonJS `require()` 调用导入路径时生效。
      可以用来提供特定于 CommonJS 的代码。
      </p>
    - >
      `browser`
      <p>
      该条件仅在 esbuild 的 [platform](#platform) 设置为 `browser` 有效。
      可以用来提供特定于浏览器的代码。
      </p>
    - >
      `node`
      <p>
      该条件仅在 esbuild 的 [platform](#platform) 设置为 `node` 有效。
      可以用来提供特定于 node 的代码。
      </p>

  - p: >
      请注意当你使用 `require` 与 `import` 条件时，_你的包可能会在 bundle 过程中多次终止！_
      这是一个微妙的问题，它可能会由于代码状态的重复副本而导致 bug，此外还会使结果包膨胀。
      这通常被称为 [dual package hazard](https://nodejs.org/docs/latest/api/packages.html#packages_dual_package_hazard)。
      避免这种情况的主要方法是将所有代码都放在 `require` 条件中，而 `import` 条件只是一个轻包装器，
      它调用包上的 `require` ，并使用 ESM 语法重新导出包。

  - h3: 入口名称

  - p: >
      This option controls the file names of the output files corresponding to each
      input entry point file. It configures the output paths using a template with
      placeholders that will be substituted with values specific to the file when
      the output path is generated. For example, specifying an entry name template
      of <code>[dir]/<wbr>[name]-<wbr>[hash]</code> includes a hash of the output
      file in the file name and puts the files into the output directory,
      potentially under a subdirectory (see the details about `[dir]` below).
      Doing that looks like this:

  - example:
      in:
        src/main-app/app.js: '1 + 2'

      cli: |
        esbuild src/main-app/app.js --entry-names=[dir]/[name]-[hash] --outbase=src --bundle --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['src/main-app/app.js'],
          entryNames: '[dir]/[name]-[hash]',
          outbase: 'src',
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"src/main-app/app.js"},
            AssetNames:  "[dir]/[name]-[hash]",
            Outbase:     "src",
            Bundle:      true,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      There are three placeholders that can be used in entry path templates:

  - ul:
    - >
      `[dir]`
      <p>
      This is the relative path from the directory containing the input entry
      point file to the [outbase](#outbase) directory. Its purpose is to help
      you avoid collisions between identically-named entry points in different
      subdirectories.
      </p>
      <p>
      For example, if there are two entry points
      <code>src/<wbr>pages/<wbr>home/<wbr>index.ts</code> and
      <code>src/<wbr>pages/<wbr>about/<wbr>index.ts</code>, the outbase
      directory is `src`, and the entry names template is `[dir]/[name]`,
      the output directory will contain <code>pages/<wbr>home/<wbr>index.js</code>
      and <code>pages/<wbr>about/<wbr>index.js</code>. If the entry names
      template had been just `[name]` instead, bundling would have failed
      because there would have been two output files with the same output path
      `index.js` inside the output directory.
      </p>

    - >
      `[name]`
      <p>
      This is the original file name of the entry point without the extension.
      For example, if the input entry point file is named `app.js` then `[name]`
      will be substituted with `app` in the template.
      </p>

    - >
      `[hash]`
      <p>
      This is the content hash of the output file, which can be used to take
      optimal advantage of browser caching. Adding `[hash]` to your entry
      point names means esbuild will calculate a hash that relates to all
      content in the corresponding output file (and any output file it imports
      if [code splitting](#splitting) is active). The hash is designed to change
      if and only if any of the input files relevant to that output file are
      changed.
      </p>
      <p>
      After that, you can have your web server tell browsers that to cache these
      files forever (in practice you can say they expire a very long time from
      now such as in a year). You can then use the information in the
      [metafile](#metafile) to determine which output file path corresponds to
      which input entry point so you know what path to include in your `<script>`
      tag.
      </p>

  - p: >
      Entry path templates do not need to include a file extension. The appropriate
      [out extension](#out-extension) based on the file type will be automatically
      added to the end of the output path after template substitution.

  - p: >
      This option is similar to the [asset names](#asset-names) and
      [chunk names](#chunk-names) options.

  - h3: Footer

  - p: >
      Use this to insert an arbitrary string at the end of generated JavaScript
      and CSS files. This is commonly used to insert comments:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --footer:js=//comment --footer:css=/*comment*/

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          footer: {
            js: '//comment',
            css: '/*comment*/',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Footer: map[string]string{
              "js":  "//comment",
              "css": "/*comment*/",
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      This is similar to [banner](#banner) which inserts at the beginning
      instead of the end.

  - h3: Global name

  - p: >
      This option only matters when the [format](#format) setting is `iife`
      (which stands for immediately-invoked function expression). It sets the
      name of the global variable which is used to store the exports from the
      entry point:

  - example:
      cli: |
        echo 'module.exports = "test"' | esbuild --format=iife --global-name=xyz

      js: |
        let js = 'module.exports = "test"'
        require('esbuild').transformSync(js, {
          format: 'iife',
          globalName: 'xyz',
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format:     api.FormatIIFE,
            GlobalName: "xyz",
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Specifying the global name with the `iife` format will generate code that
      looks something like this:

  - pre.js: |
      var xyz = (() => {
        ...
        var require_stdin = __commonJS((exports, module) => {
          module.exports = "test";
        });
        return require_stdin();
      })();

  - p: >
      The global name can also be a compound property expression, in which case
      esbuild will generate a global variable with that property. Existing
      global variables that conflict will not be overwritten. This can be used
      to implement "namespacing" where multiple independent scripts add their
      exports onto the same global object. For example:

  - example:
      cli: |
        echo 'module.exports = "test"' | esbuild --format=iife --global-name='example.versions["1.0"]'

      js: |
        let js = 'module.exports = "test"'
        require('esbuild').transformSync(js, {
          format: 'iife',
          globalName: 'example.versions["1.0"]',
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format:     api.FormatIIFE,
            GlobalName: `example.versions["1.0"]`,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      The compound global name used above generates code that looks like this:

  - pre.js: |
      var example = example || {};
      example.versions = example.versions || {};
      example.versions["1.0"] = (() => {
        ...
        var require_stdin = __commonJS((exports, module) => {
          module.exports = "test";
        });
        return require_stdin();
      })();

  - h3: Incremental

  - p: >
      You may want to use this API if your use case involves calling esbuild's
      [build API](#build-api) repeatedly with the same options. For example,
      this is useful if you are implementing a file watcher service. Incremental
      builds are more efficient than regular builds because some of the data is
      cached and can be reused if the original files haven't changed since the
      last build. There are currently two forms of caching used by the
      incremental build API:

  - ul:
    - >
      <p>
      Files are stored in memory and are not re-read from the file system if
      the file metadata hasn't changed since the last build. This optimization
      only applies to file system paths. It does not apply to virtual modules
      created by [plugins](/plugins/).
      </p>

    - >
      <p>
      Parsed [ASTs](https://en.wikipedia.org/wiki/Abstract_syntax_tree) are
      stored in memory and re-parsing the AST is avoided if the file contents
      haven't changed since the last build. This optimization applies to
      virtual modules created by plugins in addition to file system modules,
      as long as the virtual module path remains the same.
      </p>

  - p: >
      Here's how to do an incremental build:

  - example:
      in:
        app.js: '1 + 2'

      js: |
        async function example() {
          let result = await require('esbuild').build({
            entryPoints: ['app.js'],
            bundle: true,
            outfile: 'out.js',
            incremental: true,
          })

          // Call "rebuild" as many times as you want
          for (let i = 0; i < 5; i++) {
            let result2 = await result.rebuild()
          }

          // Call "dispose" when you're done to free up resources.
          result.rebuild.dispose()
        }

        example()

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outfile:     "out.js",
            Incremental: true,
          })
          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          // Call "Rebuild" as many times as you want
          for i := 0; i < 5; i++ {
            result2 := result.Rebuild()
            if len(result2.Errors) > 0 {
              os.Exit(1)
            }
          }
        }

  - h3: JSX factory

  - p: >
      This sets the function that is called for each JSX element. Normally a
      JSX expression such as this:

  - pre.xml: |
      <div>Example text</div>

  - p: >
      is compiled into a function call to `React.createElement` like this:

  - pre.js: |
      React.createElement("div", null, "Example text");

  - p: >
      You can call something other than `React.createElement` by changing the
      JSX factory. For example, to call the function `h` instead (which is
      used by other libraries such as [Preact](https://preactjs.com/)):

  - example:
      cli:
        - $: |
            echo '<div/>' | esbuild --jsx-factory=h --loader=jsx
        - expect: |
            /* @__PURE__ */ h("div", null);

      js:
        - $: |
            require('esbuild').transformSync('<div/>', {
              jsxFactory: 'h',
              loader: 'jsx',
            })
        - expect: |
            {
              code: '/* @__PURE__ */ h("div", null);\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("<div/>", api.TransformOptions{
            JSXFactory: "h",
            Loader:     api.LoaderJSX,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Alternatively, if you are using TypeScript, you can just configure JSX
      for TypeScript by adding this to your `tsconfig.json` file and esbuild
      should pick it up automatically without needing to be configured:

  - pre.json: |
      {
        "compilerOptions": {
          "jsxFactory": "h"
        }
      }

  - h3: JSX fragment

  - p: >
      This sets the function that is called for each JSX fragment. Normally a
      JSX fragment expression such as this:

  - pre.xml: |
      <>Stuff</>

  - p: >
      is compiled into a use of the `React.Fragment` component like this:

  - pre.js: |
      React.createElement(React.Fragment, null, "Stuff");

  - p: >
      You can use a component other than `React.Fragment` by changing the
      JSX fragment. For example, to use the component `Fragment` instead
      (which is used by other libraries such as [Preact](https://preactjs.com/)):

  - example:
      cli:
        - $: |
            echo '<>x</>' | esbuild --jsx-fragment=Fragment --loader=jsx
        - expect: |
            /* @__PURE__ */ React.createElement(Fragment, null, "x");

      js:
        - $: |
            require('esbuild').transformSync('<>x</>', {
              jsxFragment: 'Fragment',
              loader: 'jsx',
            })
        - expect: |
            {
              code: '/* @__PURE__ */ React.createElement(Fragment, null, "x");\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("<>x</>", api.TransformOptions{
            JSXFragment: "Fragment",
            Loader:      api.LoaderJSX,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Alternatively, if you are using TypeScript, you can just configure JSX
      for TypeScript by adding this to your `tsconfig.json` file and esbuild
      should pick it up automatically without needing to be configured:

  - pre.json: |
      {
        "compilerOptions": {
          "jsxFragmentFactory": "Fragment"
        }
      }

  - h3: Keep names

  - p: >
      In JavaScript the `name` property on functions and classes defaults to a
      nearby identifier in the source code. These syntax forms all set the `name`
      property of the function to `"fn"`:

  - pre.js: |
      function fn() {}
      let fn = function() {};
      fn = function() {};
      let [fn = function() {}] = [];
      let {fn = function() {}} = {};
      [fn = function() {}] = [];
      ({fn = function() {}} = {});

  - p: >
      However, [minification](#minify) renames symbols to reduce code size and
      [bundling](#bundle) sometimes need to rename symbols to avoid collisions.
      That changes value of the `name` property for many of these cases. This
      is usually fine because the `name` property is normally only used for
      debugging. However, some frameworks rely on the `name` property for
      registration and binding purposes. If this is the case, you can enable
      this option to preserve the original `name` values even in minified code:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --minify --keep-names

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          minify: true,
          keepNames: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.js"},
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            KeepNames:         true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Log level

  - p: >
      The log level can be changed to prevent esbuild from printing warning
      and/or error messages to the terminal. The four log levels are `info`
      (show everything), `warning` (show warnings and errors), `error`
      (just show errors), and `silent` (show nothing).

  - p: >
      For example, you can hide all warnings by setting the log level to
      `error`:

  - example:
      cli: |
        echo 'typeof x == "null"' | esbuild --log-level=error

      js: |
        let js = 'typeof x == "null"'
        require('esbuild').transformSync(js, {
          logLevel: 'error',
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "typeof x == 'null'"

          result := api.Transform(js, api.TransformOptions{
            LogLevel: api.LogLevelError,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Log limit

  - p: >
      By default, esbuild stops reporting log messages after 10 messages have
      been reported. This avoids the accidental generation of an overwhelming number
      of log messages, which can easily lock up slower terminal emulators such
      as Windows command prompt. It also avoids accidentally using up the
      whole scroll buffer for terminal emulators with limited scroll buffers.

  - p: >
      The log limit can be changed to another value, and can also be disabled
      completely by setting it to zero. This will show all log messages:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --log-limit=0

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          logLimit: 0,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            LogLimit:    0,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Main fields

  - p: >
      When you import a package in node, the `main` field in that package's
      `package.json` file determines which file is imported (along with
      [a lot of other rules](https://nodejs.org/api/modules.html#modules_all_together)).
      Major JavaScript bundlers including esbuild let you specify additional
      `package.json` fields to try when resolving a package. There are at least
      three such fields commonly in use:

  - ul:
    - >
      `main`
      <p>
      This is [the standard field](https://docs.npmjs.com/files/package.json#main)
      for all packages that are meant to be used with node. The name `main` is
      hard-coded in to node's module resolution logic itself. Because it's
      intended for use with node, it's reasonable to expect that the file path
      in this field is a CommonJS-style module.
      </p>

    - >
      `module`
      <p>
      This field came from [a proposal](https://github.com/dherman/defense-of-dot-js/blob/f31319be735b21739756b87d551f6711bd7aa283/proposal.md)
      for how to integrate ECMAScript modules into node. Because of this, it's
      reasonable to expect that the file path in this field is an
      ECMAScript-style module. This proposal wasn't adopted by node (node uses
      <code>"type": <wbr>"module"</code> instead) but it was adopted by major
      bundlers because ECMAScript-style modules lead to better [tree shaking](#tree-shaking),
      or dead code removal.
      </p>
      <p>
      For package authors: Some packages incorrectly use the `module` field for
      browser-specific code, leaving node-specific code for the `main` field.
      This is probably because node ignores the `module` field and people
      typically only use bundlers for browser-specific code. However, bundling
      node-specific code is valuable too (e.g. it decreases download and boot
      time) and packages that put browser-specific code in `module` prevent
      bundlers from being able to do tree shaking effectively. If you are
      trying to publish browser-specific code in a package, use the `browser`
      field instead.
      </p>

    - >
      `browser`
      <p>
      This field came from [a proposal](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211)
      that allows bundlers to replace node-specific files or modules with their
      browser-friendly versions. It lets you specify an alternate
      browser-specific entry point. Note that it is possible for a package to
      use both the `browser` and `module` field together (see the note below).
      </p>

  - p: >
      The default main fields depend on the current [platform](#platform)
      setting and are essentially <code>browser,<wbr>module,<wbr>main</code>
      for the browser and <code>main,<wbr>module</code> for node. These
      defaults should be the most widely compatible with the existing package
      ecosystem. But you can customize them like this if you want to:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --main-fields=module,main

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          mainFields: ['module', 'main'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            MainFields:  []string{"module", "main"},
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      For package authors: If you want to author a package that uses the
      `browser` field in combination with the `module` field to fill out all
      four entries in the full CommonJS-vs-ESM and browser-vs-node compatibility
      matrix, you want to use the expanded form of the `browser` field that is a
      map instead of just a string:

  - pre.json: >
      {
        "main": "./node-cjs.js",
        "module": "./node-esm.js",
        "browser": {
          "./node-cjs.js": "./browser-cjs.js",
          "./node-esm.js": "./browser-esm.js"
        }
      }

  - h3: Metafile

  - p: >
      This option tells esbuild to produce some metadata about the build in
      JSON format. The following example puts the metadata in a file called
      `meta.json`:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --metafile=meta.json --outfile=out.js

      js: |
        const result = require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          metafile: true,
          outfile: 'out.js',
        })
        require('fs').writeFileSync('meta.json',
          JSON.stringify(result.metafile))

      go: |
        package main

        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Metafile:    true,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          ioutil.WriteFile("meta.json", []byte(result.Metafile), 0644)
        }

  - p: >
      This data can then be analyzed by other tools. For example,
      [bundle buddy](https://www.bundle-buddy.com/esbuild) can consume esbuild's
      metadata format and generates a treemap visualization of the modules in
      your bundle and how much space each one takes up.

  - p: >
      The metadata JSON format looks like this (described using a TypeScript
      interface):

  - pre.ts: |
      interface Metadata {
        inputs: {
          [path: string]: {
            bytes: number
            imports: {
              path: string
              kind: string
            }[]
          }
        }
        outputs: {
          [path: string]: {
            bytes: number
            inputs: {
              [path: string]: {
                bytesInOutput: number
              }
            }
            imports: {
              path: string
              kind: string
            }[]
            exports: string[]
            entryPoint?: string
          }
        }
      }

  - h3: Node paths

  - p: >
      Node's module resolution algorithm supports an environment variable called
      [`NODE_PATH`](https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders)
      that contains a list of global directories to use when resolving import
      paths. These paths are searched for packages in addition to the
      `node_modules` directories in all parent directories. You can pass this
      list of directories to esbuild using an environment variable with the CLI
      and using an array with the JS and Go APIs:

  - example:
      in:
        app.js: 'import {x} from "test"'
        someDir/test.js: 'export let x'

      cli: |
        NODE_PATH=someDir esbuild app.js --bundle --outfile=out.js

      js: |
        require('esbuild').buildSync({
          nodePaths: ['someDir'],
          entryPoints: ['app.js'],
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            NodePaths:   []string{"someDir"},
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      If you are using the CLI and want to pass multiple directories using
      `NODE_PATH`, you will have to separate them with `:` on Unix and `;` on
      Windows. This is the same format that Node itself uses.

  - h3: Out extension

  - p: >
      This option lets you customize the file extension of the files that
      esbuild generates to something other than `.js` or `.css`. In particular,
      the `.mjs` and `.cjs` file extensions have special meaning in node (they
      indicate a file in ESM and CommonJS format, respectively). This option is
      useful if you are using esbuild to generate multiple files and you have
      to use the [outdir](#outdir) option instead of the [outfile](#outfile)
      option. You can use it like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --outdir=dist --out-extension:.js=.mjs

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          outdir: 'dist',
          outExtension: { '.js': '.mjs' },
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "dist",
            OutExtensions: map[string]string{
              ".js": ".mjs",
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Outbase

  - p: >
      If your build contains multiple entry points in separate directories, the
      directory structure will be replicated into the [output directory](#outdir)
      relative to the outbase directory. For example, if there are two entry
      points <code>src/<wbr>pages/<wbr>home/<wbr>index.ts</code> and
      <code>src/<wbr>pages/<wbr>about/<wbr>index.ts</code> and the outbase directory is
      `src`, the output directory will contain <code>pages/<wbr>home/<wbr>index.js</code>
      and <code>pages/<wbr>about/<wbr>index.js</code>. Here's how to use it:

  - example:
      in:
        src/pages/home/index.ts: '1 + 2'
        src/pages/about/index.ts: '3 + 4'

      cli: |
        esbuild src/pages/home/index.ts src/pages/about/index.ts --bundle --outdir=out --outbase=src

      js: |
        require('esbuild').buildSync({
          entryPoints: [
            'src/pages/home/index.ts',
            'src/pages/about/index.ts',
          ],
          bundle: true,
          outdir: 'out',
          outbase: 'src',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{
              "src/pages/home/index.ts",
              "src/pages/about/index.ts",
            },
            Bundle:  true,
            Outdir:  "out",
            Outbase: "src",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      If the outbase directory isn't specified, it defaults to the
      [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor)
      directory among all input entry point paths. This is <code>src/<wbr>pages</code>
      in the example above, which means by default the output directory will
      contain <code>home/<wbr>index.js</code> and <code>about/<wbr>index.js</code>
      instead.

  - h3: Preserve symlinks

  - p: >
      This setting mirrors the [`--preserve-symlinks`](https://nodejs.org/api/cli.html#cli_preserve_symlinks)
      setting in node. If you use that setting (or the similar [`resolve.symlinks`](https://webpack.js.org/configuration/resolve/#resolvesymlinks)
      setting in Webpack), you will likely need to enable this setting in
      esbuild too. It can be enabled like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --preserve-symlinks --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          preserveSymlinks: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:      []string{"app.js"},
            Bundle:           true,
            PreserveSymlinks: true,
            Outfile:          "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Enabling this setting causes esbuild to determine file identity by the
      original file path (i.e. the path without following symlinks) instead of
      the real file path (i.e. the path after following symlinks). This can be
      beneficial with certain directory structures. Keep in mind that this means
      a file may be given multiple identities if there are multiple symlinks
      pointing to it, which can result in it appearing multiple times in
      generated output files.

  - p: >
      _Note: The term "symlink" means [symbolic link](https://en.wikipedia.org/wiki/Symbolic_link)
      and refers to a file system feature where a path can redirect to another
      path._

  - h3: Public path

  - p: >
      This is useful in combination with the [external file](/content-types/#external-file)
      loader. By default that loader exports the name of the imported file as a
      string using the `default` export. The public path option lets you
      prepend a base path to the exported string of each file loaded by this
      loader:

  - example:
      in:
        app.js: |
          import url from './example.png'
          let image = new Image
          image.src = url
          document.body.appendChild(image)
        example.png: |
          this is some data

      cli: |
        esbuild app.js --bundle --loader:.png=file --public-path=https://www.example.com/v1 --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          loader: { '.png': 'file' },
          publicPath: 'https://www.example.com/v1',
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Loader: map[string]api.Loader{
              ".png": api.LoaderFile,
            },
            Outdir:     "out",
            PublicPath: "https://www.example.com/v1",
            Write:      true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Pure

  - p: >
      There is a convention used by various JavaScript tools where a special
      comment containing either `/* @__PURE__ */` or `/* #__PURE__ */` before
      a new or call expression means that that expression can be removed if the
      resulting value is unused. It looks like this:

  - pre.js: |
      let button = /* @__PURE__ */ React.createElement(Button, null);

  - p: >
      This information is used by bundlers such as esbuild during tree shaking
      (a.k.a. dead code removal) to perform fine-grained removal of unused
      imports across module boundaries in situations where the bundler is not
      able to prove by itself that the removal is safe due to the dynamic
      nature of JavaScript code.

  - p: >
      Note that while the comment says "pure", it confusingly does _not_
      indicate that the function being called is pure. For example, it does not
      indicate that it is ok to cache repeated calls to that function. The name
      is essentially just an abstract shorthand for "ok to be removed if unused".

  - p: >
      Some expressions such as JSX and certain built-in globals are automatically
      annotated as `/* @__PURE__ */` in esbuild. You can also configure additional
      globals to be marked `/* @__PURE__ */` as well. For example, you can mark
      the global `console.log` function as such to have it be automatically
      removed from your bundle when the bundle is minified as long as the result
      isn't used.

  - p: >
      It's worth mentioning that the effect of the annotation only extends to
      the call itself, not to the arguments. Arguments with side effects are
      still kept:

  - example:
      cli:
        - $: |
            echo 'console.log("foo:", foo())' | esbuild --pure:console.log
        - expect: |
            /* @__PURE__ */ console.log("foo:", foo());
        - $: |
            echo 'console.log("foo:", foo())' | esbuild --pure:console.log --minify
        - expect: |
            foo();

      js:
        - $: |
            let js = 'console.log("foo:", foo())'
        - $: |
            require('esbuild').transformSync(js, {
              pure: ['console.log'],
            })
        - expect: |
            {
              code: '/* @__PURE__ */ console.log("foo:", foo());\n',
              map: '',
              warnings: []
            }
        - $: |
            require('esbuild').transformSync(js, {
              pure: ['console.log'],
              minify: true,
            })
        - expect: |
            {
              code: 'foo();\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "console.log('foo:', foo())"

          result1 := api.Transform(js, api.TransformOptions{
            Pure: []string{"console.log"},
          })

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(js, api.TransformOptions{
            Pure:         []string{"console.log"},
            MinifySyntax: true,
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }
        }

  - h3: Resolve extensions

  - p: >
      The [resolution algorithm used by node](https://nodejs.org/api/modules.html#modules_file_modules)
      supports implicit file extensions. You can <code>require(<wbr>'./file')</code> and it
      will check for `./file`, `./file.js`, `./file.json`, and `./file.node` in
      that order. Modern bundlers including esbuild extend this concept to other
      file types as well. The full order of implicit file extensions in esbuild
      can be customized using the resolve extensions setting, which defaults to
      <code>.tsx,<wbr>.ts,<wbr>.jsx,<wbr>.js,<wbr>.css,<wbr>.json</code>:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
          esbuild app.js --bundle --resolve-extensions=.ts,.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          resolveExtensions: ['.ts', '.js'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.js"},
            Bundle:            true,
            ResolveExtensions: []string{".ts", ".js"},
            Write:             true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Source Root

  - p: >
      This feature is only relevant when [source maps](#sourcemap) are enabled.
      It lets you set the value of the `sourceRoot` field in the source map,
      which specifies the path that all other paths in the source map are
      relative to. If this field is not present, all paths in the source map
      are interpreted as being relative to the directory containing the source
      map instead.

  - p: >
      You can configure `sourceRoot` like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --sourcemap --source-root=https://raw.githubusercontent.com/some/repo/v1.2.3/

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          sourcemap: true,
          sourceRoot: 'https://raw.githubusercontent.com/some/repo/v1.2.3/',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Sourcemap:   api.SourceMapInline,
            SourceRoot:  "https://raw.githubusercontent.com/some/repo/v1.2.3/",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Sourcefile

  - p: >
      This option sets the file name when using an input which has no file
      name. This happens when using the transform API and when using the build
      API with stdin. The configured file name is reflected in error messages
      and in source maps. If it's not configured, the file name defaults to
      `<stdin>`. It can be configured like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        cat app.js | esbuild --sourcefile=example.js --sourcemap

      js: |
        let fs = require('fs')
        let js = fs.readFileSync('app.js', 'utf8')

        require('esbuild').transformSync(js, {
          sourcefile: 'example.js',
          sourcemap: 'inline',
        })

      go: |
        package main

        import "fmt"
        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js, err := ioutil.ReadFile("app.js")
          if err != nil {
            panic(err)
          }

          result := api.Transform(string(js),
            api.TransformOptions{
              Sourcefile: "example.js",
              Sourcemap:  api.SourceMapInline,
            })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Sources Content

  - p: >
      [Source maps](#sourcemap) are generated using [version 3](https://sourcemaps.info/spec.html)
      of the source map format, which is by far the most widely-supported
      variant. Each source map will look something like this:

  - pre.json: |
      {
        "version": 3,
        "sources": ["bar.js", "foo.js"],
        "sourcesContent": ["bar()", "foo()\nimport './bar'"],
        "mappings": ";AAAA;;;ACAA;",
        "names": []
      }

  - p: >
      The `sourcesContent` field is an optional field that contains all of the
      original source code. This is helpful for debugging because it means the
      original source code will be available in the debugger.

  - p: >
      However, it's not needed in some scenarios. For example, if you are just
      using source maps in production to generate stack traces that contain the
      original file name, you don't need the original source code because there
      is no debugger involved. In that case it can be desirable to omit the
      `sourcesContent` field to make the source map smaller:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild --bundle app.js --sourcemap --sources-content=false

      js: |
        require('esbuild').buildSync({
          bundle: true,
          entryPoints: ['app.js'],
          sourcemap: true,
          sourcesContent: false,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            Bundle:         true,
            EntryPoints:    []string{"app.js"},
            Sourcemap:      api.SourceMapInline,
            SourcesContent: api.SourcesContentExclude,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Stdin

  - p: >
      Normally the build API call takes one or more file names as input.
      However, this option can be used to run a build without a module existing
      on the file system at all. It's called "stdin" because it corresponds to
      piping a file to stdin on the command line.

  - p: >
      In addition to specifying the contents of the stdin file, you can
      optionally also specify the resolve directory (used to determine where
      relative imports are located), the [sourcefile](#sourcefile) (the file
      name to use in error messages and source maps), and the [loader](#loader)
      (which determines how the file contents are interpreted). The CLI doesn't
      have a way to specify the resolve directory. Instead, it's automatically
      set to the current working directory.

  - p: >
      Here's how to use this feature:

  - example:
      in:
        another-file.js: 'export let foo = 123'

      cli: |
        echo 'export * from "./another-file"' | esbuild --bundle --sourcefile=imaginary-file.js --loader=ts --format=cjs

      js: |
        let result = require('esbuild').buildSync({
          stdin: {
            contents: `export * from "./another-file"`,

            // These are all optional:
            resolveDir: require('path').join(__dirname, 'src'),
            sourcefile: 'imaginary-file.js',
            loader: 'ts',
          },
          format: 'cjs',
          write: false,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            Stdin: &api.StdinOptions{
              Contents: "export * from './another-file'",

              // These are all optional:
              ResolveDir: "./src",
              Sourcefile: "imaginary-file.js",
              Loader:     api.LoaderTS,
            },
            Format: api.FormatCommonJS,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Tree shaking

  - p: >
      Tree shaking is the term the JavaScript community uses for dead code
      elimination, a common compiler optimization that automatically removes
      unreachable code. Note that tree shaking in esbuild is always enabled
      during bundling and can't be turned off, since trimming unused code
      makes the resulting file smaller without changing observable behavior.

  - p: >
      Tree shaking is easiest to explain with an example. Consider the following
      file. There is one used function and one unused function:

  - pre.js: |
      // input.js
      function one() {
        console.log('one')
      }
      function two() {
        console.log('two')
      }
      one()

  - p: >
      If you bundle this file with <code>esbuild <wbr>--bundle <wbr>input.js <wbr>--outfile=<wbr>output.js</code>,
      the unused function will automatically be discarded leaving you with the
      following output:

  - pre.js: |
      // input.js
      function one() {
        console.log("one");
      }
      one();

  - p: >
      This even works if we split our functions off into a separate library
      file and import them using an `import` statement:

  - pre.js: |
      // lib.js
      export function one() {
        console.log('one')
      }
      export function two() {
        console.log('two')
      }

  - pre.js: |
      // input.js
      import * as lib from './lib.js'
      lib.one()

  - p: >
      If you bundle this file with <code>esbuild <wbr>--bundle <wbr>input.js <wbr>--outfile=<wbr>output.js</code>,
      the unused function and unused import will still be automatically
      discarded leaving you with the following output:

  - pre.js: |
      // lib.js
      function one() {
        console.log("one");
      }

      // input.js
      one();

  - p: >
      This way esbuild will only bundle the parts of your libraries that you
      actually use, which can sometimes be a substantial size savings. Note
      that esbuild's tree shaking implementation relies on the use of ECMAScript
      module `import` and `export` statements. It does not work with CommonJS
      modules. Many libraries on npm include both formats and esbuild tries to
      pick the format that works with tree shaking by default. You can
      customize which format esbuild picks using the [main fields](#main-fields)
      option.

  - h4: Manual tree shaking annotations

  - p: >
      Since JavaScript is a dynamic language, identifying
      unused code is sometimes very difficult for a compiler, so the community
      has developed certain annotations to help tell compilers what code should
      be considered unused. Currently there are two forms of tree-shaking
      annotations that esbuild supports:

  - ul:
    - >
      <p>
      Inline `/* @__PURE__ */` comments before function calls tell esbuild that
      the function call can be removed if the resulting value isn't used. See
      the [pure](#pure) API option for more information.
      </p>

    - >
      <p>
      The `sideEffects` field in `package.json` can be used to tell esbuild
      which files in your package can be removed if all imports from that
      file end up being unused. This is a convention from Webpack and many
      libraries published to npm already have this field in their package
      definition. You can learn more about this field in
      [Webpack's documentation](https://webpack.js.org/guides/tree-shaking/)
      for this field.
      </p>

  - p: >
      These annotations can be problematic because the compiler depends
      completely on developers for accuracy, and developers occasionally
      publish packages with incorrect annotations. The `sideEffects` field is
      particularly error-prone for developers because by default it causes all
      files in your package to be considered dead code if no imports are used.
      If you add a new file containing side effects and forget to update that
      field, your package will likely break when people try to bundle it.

  - p: >
      This is why esbuild includes a way to ignore tree-shaking annotations.
      You should only enable this if you encounter a problem where the bundle
      is broken because necessary code was unexpectedly removed from the bundle:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
          esbuild app.js --bundle --tree-shaking=ignore-annotations

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          treeShaking: 'ignore-annotations',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            TreeShaking: api.TreeShakingIgnoreAnnotations,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Enabling this means esbuild will no longer respect `/* @__PURE__ */`
      comments or the `sideEffects` field. It will still do automatic tree
      shaking of unused imports, however, since that doesn't rely on
      annotations from developers. Ideally this flag is only a temporary
      workaround. You should report these issues to the maintainer of the
      package to get them fixed since they indicate a problem with the package
      and they will likely trip up other people too.

  - h3: Tsconfig

  - p: >
      Normally the [build API](#build-api) automatically discovers `tsconfig.json`
      files and reads their contents during a build. However, you can also
      configure a custom `tsconfig.json` file to use instead. This can be
      useful if you need to do multiple builds of the same code with different
      settings:

  - example:
      in:
        app.ts: '1 + 2'
        custom-tsconfig.json: '{}'

      cli: |
          esbuild app.ts --bundle --tsconfig=custom-tsconfig.json

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          bundle: true,
          tsconfig: 'custom-tsconfig.json',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Bundle:      true,
            Tsconfig:    "custom-tsconfig.json",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Tsconfig raw

  - p: >
      This option can be used to pass your `tsconfig.json` file to the
      [transform API](#transform-api), which doesn't access the file system.
      Using it looks like this:

  - example:
      cli: |
          echo 'class Foo { foo }' | esbuild --loader=ts --tsconfig-raw='{"compilerOptions":{"useDefineForClassFields":true}}'

      js: |
        let ts = 'class Foo { foo }'
        require('esbuild').transformSync(ts, {
          loader: 'ts',
          tsconfigRaw: `{
            "compilerOptions": {
              "useDefineForClassFields": true,
            },
          }`,
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          ts := "class Foo { foo }"

          result := api.Transform(ts, api.TransformOptions{
            Loader: api.LoaderTS,
            TsconfigRaw: `{
              "compilerOptions": {
                "useDefineForClassFields": true,
              },
            }`,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Working Directory

  - p: >
      This API option lets you specify the working directory to use for the
      build. It normally defaults to the [current working directory](https://en.wikipedia.org/wiki/Working_directory)
      of the process you are using to call esbuild's API. The working directory
      is used by esbuild for a few different things including resolving relative
      paths given as API options to absolute paths and pretty-printing absolute
      paths as relative paths in log messages. Here is how to override it:

  - example:
      in:
        file.js: 'export let foo = 123'

      js: |
        require('esbuild').buildSync({
          entryPoints: ['file.js'],
          absWorkingDir: process.cwd(),
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "log"
        import "os"

        func main() {
          cwd, err := os.Getwd()
          if err != nil {
            log.Fatal(err)
          }

          result := api.Build(api.BuildOptions{
            EntryPoints:   []string{"file.js"},
            AbsWorkingDir: cwd,
            Outfile:       "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h2: JS-specific details

  - p: >
      Because JavaScript is single-threaded, there are several different ways
      to invoke the API with different performance and convenience tradeoffs.
      It's important to be aware of the differences to pick the correct one for
      your situation.

  - p: >
      First there is the synchronous API. This is the most convenient option
      because single-threaded JavaScript code has the cleanest syntax. It's
      also optimal performance-wise if all you need to do is run esbuild and
      then exit. However, it blocks the main thread so you do not want to use
      it if you have other work to perform in the meantime. This is also the
      only option that cannot use plugins (since plugins are asynchronous).
      It looks like this:

  - pre.js: |
      let esbuild = require('esbuild')
      let result1 = esbuild.transformSync(code, options)
      let result2 = esbuild.buildSync(options)

  - p: >
      Then there is the asynchronous API. Each call returns a promise instead
      of completing immediately. Under the hood, the esbuild binary is spawned
      as a single child process shared between all calls in the host process.
      The host communicates with the child over the stdin, stdout, and stderr
      pipes using a custom binary protocol. This is ideal if you only need to
      run esbuild once but you need to do other work in the background. It also
      allows you to run many simultaneous esbuild API calls concurrently which
      are then spread across all available cores for maximum performance. Using
      it looks something like this:

  - pre.js: |
      let esbuild = require('esbuild')
      esbuild.transform(code, options).then(result => { ... })
      esbuild.build(options).then(result => { ... })

  - h3: Running in the browser
  - p: >
      The esbuild API can also run in the browser using WebAssembly in a Web
      Worker. To take advantage of this you will need to install the
      `esbuild-wasm` package instead of the `esbuild` package:

  - pre: |
      npm install esbuild-wasm

  - p: >
      The API for the browser is similar to the API for node except that you
      need to call `initialize()` first, and you need to pass the URL of
      the WebAssembly binary. The synchronous versions of the API are also
      not available. Assuming you are using a bundler, that would look
      something like this:

  - pre.js: |
      let esbuild = require('esbuild-wasm')

      esbuild.initialize({
        wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
      }).then(() => {
        esbuild.transform(code, options).then(result => { ... })
        esbuild.build(options).then(result => { ... })
      })

  - p: >
      If you're already running this code from a worker and don't want
      `initialize` to create another worker, you can pass <code>worker: <wbr>false</code>
      to it. Then it will create a WebAssembly module in the same thread
      as the thread that calls `initialize`.

  - p: >
      You can also use esbuild's API as a script tag in a HTML file without
      needing to use a bundler by injecting the `lib/browser.min.js` file. In
      this case the API creates a global called `esbuild` that holds the API
      object:

  - pre.html: |
      <script src="./node_modules/esbuild-wasm/lib/browser.min.js"></script>
      <script>
        esbuild.initialize({
          wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
        }).then(() => { ... })
      </script>

  - p: >
      If you need to use this API with ECMAScript modules, you should import
      the `esm/browser.min.js` file instead:

  - pre.html: |
      <script type="module">
        import * as esbuild from './node_modules/esbuild-wasm/esm/browser.min.js'

        esbuild.initialize({
          wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
        }).then(() => { ... })
      </script>
